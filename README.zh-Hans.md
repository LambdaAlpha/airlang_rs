# Air 编程语言

## 设计目标

- **极简**  
  语言是程序员间的共识，语言越简单，共识就越稳固，代码就越容易理解。因此，我们致力于避免引入非必要的复杂性。基于这一原则，我们不在语言核心中内置模块、控制流、赋值、模式匹配和类型构造器等特性。
- **普适**  
  一门语言的适用场景越广，学习它的投入产出比就越高，项目间的互操作性就越好。因此，我们努力使语言能适应各类目标和资源规模。基于这一原则，我们为用户提供对上下文，配置和资源的管理能力。

## 语言特性

### 极简语法

Air 的语法非常简洁，它仅包含注释和 11 种数据类型，不包含函数，类型，模块等语义特定语法，而且它的规则非常简单，使用前缀避免歧义，只有 5 个关键词（`_`，`.`，`:`，`true`，`false`）。这使得它非常适合用作配置语言或数据交换格式。

**注释**

`_(t1 t2 ... tn)`

```air
_("comment")
[1, _(2, 3,) 4]
{a : _(1, b :) 2}
```

**单元**

```air
.
```

**比特**

```air
true
false
```

**键**

```air
key

>=

a.b.c

'[0, 1, 2]'

' abcdefghijklmnopqrstuvwxyz
| ABCDEFGHIJKLMNOPQRSTUVWXYZ
|(()[]{}<>\|/'"`^~-+=*_.,:;!?@#$%&
|)0123456789'
```

**文本**

```air
"🜁^u(1F701)"

"- a^r^n^t- a.1^r^n^t- a.2"

 "- a
+   - a.1
+   - a.2"
```

**整数**

```air
123
0-123
integer(-123)
0X7f
0-B1110
```

**数**

```air
0.1
0-0.1
1.0E-1
number(-0.1)
```

**字节**

```air
byte(B00001111)
byte(X00ffff)
```

**配对**

`first : second`

```air
a : 1
a : b : c
```

**列表**

`[v1, v2, ..., vn]`

```air
[0, 1, 2]
[., false, 0, '',]
```

**映射**

`{k1 : v1, k2 : v2, ..., kn : vn}`

```air
{a : 1, b : 2, c : 3}
{a : 1, b : true, c : ' ',}
{a, b, c}
```

**调用**

- `_ function input`
- `input function _`
- `first function second`

```air
_ not true
1 + 1
a and b or c
```

### 极简语义

Air 的求值规则非常简洁，只有四条规则。

第一，键的求值规则如下：

1. `_a` ➔ `_a`
2. `.a` ➔ `a`
3. `:a` 或 `a` ➔ `v`，`v` 为上下文中键 `a` 所绑定的值

第二，调用的求值规则为 `_ f i` ➔ `o`，步骤如下：

1. `eval(f)` ➔ `vf`
2. `if vf.raw_input then i else eval(i)` ➔ `vi`
3. `vf(vi)` ➔ `o`

第三，配对，列表，映射的求值规则如下：

- `v1 : v2` ➔ `eval(v1) : eval(v2)`
- `[v1, v2, ..., vn]` ➔ `[eval(v1), eval(v2), ..., eval(vn)]`
- `{k1 : v1, k2 : v2, ..., kn : vn}` ➔ `{k1 : eval(v1), k2 : eval(v2), kn : eval(vn)}`

第四，其他值的求值规则为 `v` ➔ `v`。

### 上下文

上下文是执行过程中的局部信息坏境，在核心语义中可以通过键访问上下文，函数也支持感知或更新上下文。可通过 `get` 函数读取上下文中的变量，或通过 `set` 函数更新上下文中的变量，亦可通过 `which` 函数指定上下文。我们基于函数的这项特性实现了各种控制流函数，包含顺序执行 `do`，条件执行 `test`，模式匹配 `match`，循环 `loop`，迭代 `iterate` 等，并在初始上下文中提供了最常用和最必要的核心函数。

```air
_ do [
    .sum set 0,
    100 iterate i : [
        .sum set sum + i
    ],
    sum
]
```

### 配置

配置是执行过程中的全局信息坏境，通过仅追加与局域覆盖等机制，兼顾了灵活性和可预测性。可通过 `import` 函数导入配置项，或通过 `export` 函数导出配置项，亦可通过 `with` 函数局域覆盖配置项。我们将基于配置机制实现模块管理、测试框架和异常处理等特性，并在初始配置中提供了原生函数和标准库。

```air
_ do [
    .push set _ import _list.push,
    _list.add export push,
    _list.append export push,
]
```

### 资源

资源是执行过程中必需且消耗的稀缺实体，其中最核心的是执行时间与存储空间。可通过 `available_steps` 读取可用执行步数，或通过 `measure_steps` 测量实际执行步数，亦可通过 `limit_steps` 限制可用执行步数。我们将围绕这些基础能力逐步构建起资源管理框架，为人工智能等资源敏感型应用的开发提供必要的基础能力。

```air
_ do [
    .limit_steps set _ import _resource.limit_steps,
    100 limit_steps _ data true loop []
]
```

## 路线图

1. **提升语言表达能力**  
   重点扩展核心表达能力，为后续能力奠定基础。

2. **引入抽象语义与程序优化框架**  
   引入“具体值+抽象约束”的抽象语义模型，在保持语义等价的前提下实现值的同类优化，并基于此构建通用的程序优化框架。

3. **开发智能优化算法**  
   研发自动化、智能化的抽象语义程序优化算法，实现对程序资源使用的系统性优化。

## 安装

```bash
cargo install airlang_bin
```

## 许可证

您可以选择使用

* Apache 2.0 许可证
  ([LICENSE-APACHE](LICENSE-APACHE) 或 <http://www.apache.org/licenses/LICENSE-2.0>)
* MIT 许可证
  ([LICENSE-MIT](LICENSE-MIT) 或 <http://opensource.org/licenses/MIT>)

## 贡献

除非您明确说明，否则您有意提交以纳入作品的任何贡献（如 Apache-2.0 许可证中所定义），均应按照上述方式获得双重许可，无任何附加条款或条件。
