recursive call
-----
_ do [
    f = _ function {
        call_setup : eval@,
        code : (._ : .i) : .i,
    },
    _ f _ not true
]
-----
false
=====
call external func
-----
_ do [
    f = _ function {
        call_setup : eval@,
        code : (._ : .i) : _ not .i
    },
    _ f _ not true
]
-----
true
=====
call internal func
-----
_ do [
    context = _ import .context.new,
    f = _ function {
        call_setup : eval@,
        code : (._ : .i) : _ .not .i,
        context : _ context {
            not : . : not
        },
    },
    _ f _ not true
]
-----
true
=====
call rename
-----
_ do [
    context = _ import .context.new,
    f = _ function {
        call_setup : eval@,
        code : (._ : .a) : _ .n .a,
        context : _ context {
            n : . : not
        },
    },
    _ f _ not true
]
-----
true
=====
stateful
-----
_ do [
    context = _ import .context.new,
    new_link = _ import .link.new,
    link_get = _ import .link.get,
    link_set = _ import .link.set,
    f = _ function {
        context_access : .free,
        call_setup : eval@,
        code : ._ : _ do [
            .i = .a link_get _,
            .a link_set .i + 1,
            .i
        ],
        context : _ context {
            a : . : _ new_link 0
        },
    },
    [_ f ., _ f ., _ f .]
]
-----
[0, 1, 2]
=====
multiple stateful
-----
_ do [
    context = _ import .context.new,
    new_link = _ import .link.new,
    link_get = _ import .link.get,
    link_set = _ import .link.set,
    f = _ form _ function {
        context_access : .free,
        call_setup : eval@,
        code : ._ : _ do [
            .i = .a link_get _,
            .a link_set .i + 1,
            .i
        ],
        context : _ context {
            a : . : _ new_link 0
        },
    },
    f1 = $f,
    f2 = $f,
    [_ f1 ., _ f1 ., _ f1 ., _ f2 ., _ f2 ., _ f2 .]
]
-----
[0, 1, 2, 0, 1, 2]
=====
const const
-----
_ do [
    read = _ import .context.read,
    a = 1,
    f = _ function {
        code : (.c : ._) : .c ; read ..a,
        context_access : .constant,
    },
    _ f .
]
-----
1
=====
mutable const
-----
_ do [
    read = _ import .context.read,
    a = 1,
    f = _ function {
        code : (.c : ._) : .c ; read ..a,
        context_access : .mutable,
    },
    _ f .
]
-----
1
=====
mutable mutate
-----
_ do [
    f = _ function {
        code : (.c : .i) : .c ; _ .@i = 2,
        context_access : .mutable,
    },
    a = 1,
    _ f a,
    a
]
-----
2
=====
const mutate fail
-----
_ do [
    f = _ function {
        code : (.c : .i) : .c ; _ .@i = 2,
        context_access : .constant,
    },
    a = 1,
    _ f a,
    a
]
-----
1
=====
const free
-----
_ do [
    a = .,
    f = _ function {
        code : (._c : ._) : 1,
        context_access : .constant,
    },
    a ; f .
]
-----
1
=====
ctx name occupied
-----
_ do [
    context = _ import .context.new,
    a = 1,
    f = _ function {
        code : (.ctx : ._) : 2,
        context_access : .constant,
        context : _ context {
            ctx : constant : 3
        },
    },
    _ f .,
    a == 1
]
-----
true
=====
ctx explicit
-----
_ do [
    set_first = _ import .pair.set_first,
    a = 1 : 2,
    f = _ function {
        call_setup : _ mode {
            pair : {} : {symbol : ..} : eval@
        },
        code : (.p : .i) : .p ; set_first .i,
    },
    a ; f 3,
    a
]
-----
3 : 2
=====
repr
-----
_ do [
    represent = _ import .function.represent,
    _ represent _ function {
        code : (._ : .i) : .i
    }
]

-----
{code : (_ : i) : i}
=====
repr primitive free
-----
_ do [
    represent = _ import .function.represent,
    _ represent not
]
-----
{id : bit.not}
=====
repr const
-----
_ do [
    represent = _ import .function.represent,
    _ represent _ function {
        code : (._ : .i) : .i,
        context_access : .constant
    }
]
-----
{code : (_ : i) : i, context_access : constant}
=====
repr primitive const
-----
_ do [
    represent = _ import .function.represent,
    _ represent ==
]
-----
{id : ==}
=====
repr composite
-----
_ do [
    represent = _ import .function.represent,
    m = _ mode {
        pair : {} : eval@ : .
    },
    repr = _ form. {
        id : f,
        code : (ctx : in) : in,
        call_setup : @m,
        solve_setup : @m,
        context_access : constant,
    },
    new_repr = _ represent _ function repr,
    repr == new_repr
]
-----
true
=====
access free
-----
_ do [
    context_access = _ import .function.context_access,
    function ; context_access .
]
-----
free
=====
access const
-----
_ do [
    context_access = _ import .function.context_access,
    read = _ import .context.read,
    read ; context_access .
]
-----
constant
=====
access mutable
-----
_ do [
    context_access = _ import .function.context_access,
    eval@ ; context_access .
]
-----
mutable
=====
access default
-----
_ do [
    context_access = _ import .function.context_access,
    f = _ function {},
    f ; context_access .
]
-----
mutable
=====
call setup primitive
-----
_ do [
    call_setup = _ import .function.call_setup,
    eval@ == not ; call_setup .
]
-----
true
=====
call setup mode
-----
_ do [
    call_setup = _ import .function.call_setup,
    . == eval@ ; function.call_setup .
]
-----
true
=====
call setup 1
-----
_ do [
    call_setup = _ import .function.call_setup,
    f = _ function {
        call_setup : _ mode {
            pair : {} : eval@ : form.
        },
    },
    p1 = f ; call_setup .,
    p2 = _ mode {
        pair : {} : eval@ : form.
    },
    p1 == p2
]
-----
true
=====
call setup 2
-----
_ do [
    call_setup = _ import .function.call_setup,
    f = _ function {
        call_setup : _ mode {
            list : [eval@, form., .] : form.
        },
    },
    p1 = f ; call_setup .,
    p2 = _ mode {
        list : [eval@, form., .] : form.
    },
    p1 == p2
]
-----
true
=====
call setup 3
-----
_ do [
    call_setup = _ import .function.call_setup,
    f = _ function {
        call_setup : _ mode {
            map : {a : eval@, b : .} : . : form.
        },
    },
    p1 = f ; call_setup .,
    p2 = _ mode {
        map : {a : eval@, b : .} : . : form.
    },
    p1 == p2
]
-----
true
=====
solve setup
-----
_ do [
    solve_setup = _ import .function.solve_setup,
    eval@ == not ; solve_setup .
]
-----
true
=====
is_primitive primitive
-----
_ do [
    is_primitive = _ import .function.is_primitive,
    not ; is_primitive .
]
-----
true
=====
is_primitive composite
-----
_ do [
    is_primitive = _ import .function.is_primitive,
    f = _ function {},
    f ; is_primitive .
]
-----
false
=====
id primitive
-----
_ do [
    id = _ import .function.id,
    not ; id .
]
-----
bit.not
=====
id rename
-----
_ do [
    id = _ import .function.id,
    neg = not,
    neg ; id .
]
-----
bit.not
=====
code
-----
_ do [
    code = _ import .function.code,
    f = _ function {
        code : (.ctx : .i) : .i
    },
    f ; code .
]
-----
(ctx : i) : i
=====
ctx
-----
_ do [
    context.new = _ import .context.new,
    function.context = _ import .function.context,
    ctx = _ context.new {
        a : . : 1
    },
    f = _ function {
        context : ctx
    },
    (f ; function.context .) == ctx
]
-----
true
