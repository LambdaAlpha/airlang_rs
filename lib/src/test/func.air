recursive call
-----
; do [
    f = ; function {
        setup : eval@ : .,
        code : (._ : .i) : .i,
    },
    ; f ; not true
]
-----
false
=====
call external func
-----
; do [
    f = ; function {
        setup : eval@ : .,
        code : (._ : .i) : ; not .i
    },
    ; f ; not true
]
-----
true
=====
call internal func
-----
; do [
    f = ; function {
        setup : eval@ : .,
        code : (._ : .i) : ; .not .i,
        context : ; context {variables :  {not : not}},
    },
    ; f ; not true
]
-----
true
=====
call rename
-----
; do [
    f = ; function {
        setup : eval@ : .,
        code : (._ : .a) : ; .n .a,
        context : ; context {variables :  {n : not}},
    },
    ; f ; not true
]
-----
true
=====
cell free
-----
; do [
    f = ; function {
        code : ._ : ; do [.a = .a + 1, .a],
        context_access : free,
        cell : true,
        context : ; context {variables : {a : 0}},
    },
    [; .f ., ; .f ., ; .f .]
]
-----
[1, 2, 3]
=====
cell const
-----
; do [
    a = 1,
    f = ; function {
        code : (.c : ._) : ; do [.b = .b + .c | ..a, .b],
        context_access : constant,
        cell : true,
        context : ; context {variables : {
            b : 0,
        }},
    },
    [; .f ., ; .f ., ; .f .]
]
-----
[1, 2, 3]
=====
cell none
-----
; do [
    a = 1,
    f = ; function {
        code : (.c : ._) : ; do [
            .b = .b + .c | ..a,
            .c | ..a = ..a + 1,
            .b,
        ],
        context_access : mutable,
        cell : true,
        context : ; context {variables : {
            b : 0,
        }},
    },
    [; .f ., ; .f ., ; .f .]
]
-----
[1, 3, 6]
=====
cell mutable contract final
-----
; do [
    a = 1,
    (f . final) = ; function {
        code : (.c : ._) : ; do [
            .b = .b + .c | ..a,
            .c | ..a = ..a + 1,
            .b,
        ],
        context_access : mutable,
        cell : true,
        context : ; context {variables : {
            b : 0,
        }},
    },
    [; .f ., ; .f ., ; .f .]
]
-----
[1, 2, 3]
=====
const const
-----
; do [
    a = 1,
    f = ; function {
        code : (.c : ._) : .c | ..a,
        context_access : constant,
    },
    ; f .
]
-----
1
=====
mutable const
-----
; do [
    a = 1,
    f = ; function {
        code : (.c : ._) : .c | ..a,
        context_access : mutable,
    },
    ; f .
]
-----
1
=====
mutable mutate
-----
; do [
    f = ; function {
        code : (.c : .i) : .c | .i = 2,
        context_access : mutable,
    },
    a = 1,
    ; f a,
    a
]
-----
2
=====
const mutate fail
-----
; do [
    f = ; function {
        code : (.c : .i) : .c | .i = 2,
        context_access : constant,
    },
    a = 1,
    ; f a,
    a
]
-----
1
=====
const free
-----
; do [
    f = ; function {
        code : (._c : ._) : 1,
        context_access : constant,
    },
    . | ; f .
]
-----
1
=====
ctx name occupied
-----
; do [
    a = 1,
    f = ; function {
        code : (.ctx : ._) : 2,
        context_access : constant,
        context : ; context {variables : {ctx : 3 . .constant}},
    },
    ; f .,
    a == 1
]
-----
true
=====
ctx explicit
-----
; do [
    a = 1 : 2,
    f = ; function {
        context_explicit : true,
        setup : (; mode {pair : {symbol : ..} : eval@}) : .,
        code : (.p : .i) : .p pair.set_first .i,
    },
    a f 3,
    a
]
-----
3 : 2
=====
repr
-----
; function.represent ; function {code : (._ : .i) : .i}
-----
{code : (_ : i) : i}
=====
repr primitive free
-----
; function.represent not
-----
{id : not}
=====
repr const
-----
; function.represent ; function {code : (._ : .i) : .i, context_access : constant}
-----
{code : (_ : i) : i, context_access : constant}
=====
repr primitive const
-----
; function.represent ==
-----
{id : ==}
=====
repr composite
-----
; do [
    forward = ; mode {pair : eval@ : .},
    reverse = ; mode {pair : eval@ : .},
    repr = ; form. {
        code : (.ctx : .in) : in,
        setup : #forward : #reverse,
        context_access : constant,
        cell : true,
    },
    new_repr = ; function.represent ; function repr,
    repr == new_repr
]
-----
true
=====
access free
-----
function function.context_access .
-----
free
=====
access const
-----
read function.context_access .
-----
constant
=====
access mutable
-----
eval@ function.context_access .
-----
mutable
=====
access default
-----
; do [f = ; function {}, f function.context_access .]
-----
mutable
=====
is_context_explicit true
-----
pair.first function.is_context_explicit .
-----
true
=====
is_context_explicit false
-----
eval@ function.is_context_explicit .
-----
false
=====
forward setup primitive
-----
eval@ == not function.forward_setup .
-----
true
=====
forward setup mode
-----
. == eval@ function.forward_setup .
-----
true
=====
forward setup 1
-----
; do [
    f = ; function {
        setup : (; mode {pair : eval@ : form.}) : .,
    },
    p1 = f function.forward_setup .,
    p2 = ; mode {pair : eval@ : form.},
    p1 == p2
]
-----
true
=====
forward setup 2
-----
; do [
    f = ; function {
        setup : (; mode {list : [eval@, form., .] : form.}) : .,
    },
    p1 = f function.forward_setup .,
    p2 = ; mode {list : [eval@, form., .] : form.},
    p1 == p2
]
-----
true
=====
forward setup 3
-----
; do [
    f = ; function {
        setup : (; mode {map : {a : eval@, b : .} : . : form.}) : .,
    },
    p1 = f function.forward_setup .,
    p2 = ; mode {map : {a : eval@, b : .} : . : form.},
    p1 == p2
]
-----
true
=====
reverse setup
-----
eval@ == not function.reverse_setup .
-----
true
=====
is_primitive primitive
-----
not function.is_primitive .
-----
true
=====
is_primitive composite
-----
; do [f = ; function {}, f function.is_primitive .]
-----
false
=====
is_cell false
-----
not function.is_cell .
-----
false
=====
is_cell true
-----
; do [f = ; function {cell : true}, f function.is_cell .]
-----
true
=====
id primitive
-----
not function.id .
-----
not
=====
id rename
-----
; do [neg = not, neg function.id .]
-----
not
=====
code
-----
; do [f = ; function {code : (.ctx : .i) : .i}, f function.code .]
-----
(ctx : i) : i
=====
ctx
-----
; do [
    ctx = ; context {variables : {a : 1}},
    f = ; function {context : ctx},
    (f function.context .) == ctx
]
-----
true
