recursive call
-----
_ do [
    f = _ function {
        code : (__ : _i) : _i,
    },
    _ f _ not true
]
-----
false
=====
call external func
-----
_ do [
    f = _ function {
        code : (__ : _i) : _ not _i
    },
    _ f _ not true
]
-----
true
=====
call internal func
-----
_ do [
    memory = _ import _memory.new,
    f = _ function {
        code : (__ : _i) : _ _not _i,
        memory : _ memory {
            not : . : not
        },
    },
    _ f _ not true
]
-----
true
=====
call rename
-----
_ do [
    memory = _ import _memory.new,
    f = _ function {
        code : (__ : _a) : _ _n _a,
        memory : _ memory {
            n : . : not
        },
    },
    _ f _ not true
]
-----
true
=====
stateful
-----
_ do [
    memory = _ import _memory.new,
    new_link = _ import _link.new,
    link_get = _ import _link.get,
    link_set = _ import _link.set,
    f = _ function {
        context_access : _free,
        code : __ : _ do [
            _i = _a link_get _,
            _a link_set _i + 1,
            _i
        ],
        memory : _ memory {
            a : . : _ new_link 0
        },
    },
    [_ f ., _ f ., _ f .]
]
-----
[0, 1, 2]
=====
multiple stateful
-----
_ do [
    memory = _ import _memory.new,
    new_link = _ import _link.new,
    link_get = _ import _link.get,
    link_set = _ import _link.set,
    f = _ form _ function {
        context_access : _free,
        code : __ : _ do [
            _i = _a link_get _,
            _a link_set _i + 1,
            _i
        ],
        memory : _ memory {
            a : . : _ new_link 0
        },
    },
    f1 = $f,
    f2 = $f,
    [_ f1 ., _ f1 ., _ f1 ., _ f2 ., _ f2 ., _ f2 .]
]
-----
[0, 1, 2, 0, 1, 2]
=====
const const
-----
_ do [
    read = _ import _context.read,
    a = 1,
    f = _ function {
        code : (_c : __) : _c which _ read __a,
        context_access : _constant,
    },
    _ f .
]
-----
1
=====
mutable const
-----
_ do [
    read = _ import _context.read,
    a = 1,
    f = _ function {
        code : (_c : __) : _c which _ read __a,
        context_access : _mutable,
    },
    _ f .
]
-----
1
=====
mutable mutate
-----
_ do [
    f = _ function {
        code : (_c : _i) : _c which _.i = 2,
        context_access : _mutable,
    },
    a = 1,
    _ f _a,
    a
]
-----
2
=====
const mutate fail
-----
_ do [
    f = _ function {
        code : (_c : _i) : _c which _.i = 2,
        context_access : _constant,
    },
    a = 1,
    _ f _a,
    a
]
-----
1
=====
const free
-----
_ do [
    a = .,
    f = _ function {
        code : (__c : __) : 1,
        context_access : _constant,
    },
    a which _ f .
]
-----
1
=====
ctx name occupied
-----
_ do [
    memory = _ import _memory.new,
    a = 1,
    f = _ function {
        code : (_ctx : __) : 2,
        context_access : _constant,
        memory : _ memory {
            ctx : constant : 3
        },
    },
    _ f .,
    a == 1
]
-----
true
=====
ctx panic safe
-----
_ do [
    limit_steps = _ import _resource.limit_steps,
    f = _ function {
        context_access : _constant,
        code : (_ctx : __) : _ do [
            [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
            11
        ],
    },
    p = 1 : 2,
    10 limit_steps p which _ f .,
    p
]
-----
1 : 2
=====
ctx explicit
-----
_ do [
    set_first = _ import _pair.set_first,
    a = 1 : 2,
    f = _ function {
        code : (_p : _i) : _p which _ set_first _i,
    },
    a which _ f 3,
    a
]
-----
3 : 2
=====
repr
-----
_ do [
    represent = _ import _function.represent,
    _ represent _ function {
        code : (__ : _i) : _i
    }
]

-----
{code : (_ : i) : i}
=====
repr primitive free
-----
_ do [
    represent = _ import _function.represent,
    _ represent not
]
-----
{id : bit.not}
=====
repr const
-----
_ do [
    represent = _ import _function.represent,
    _ represent _ function {
        code : (__ : _i) : _i,
        context_access : _constant
    }
]
-----
{code : (_ : i) : i, context_access : constant}
=====
repr primitive const
-----
_ do [
    represent = _ import _function.represent,
    _ represent ==
]
-----
{id : value.equal}
=====
repr composite
-----
_ do [
    represent = _ import _function.represent,
    repr = _ form_ {
        id : f,
        code : (ctx : in) : in,
        context_access : constant,
    },
    new_repr = _ represent _ function repr,
    repr == new_repr
]
-----
true
=====
access free
-----
_ do [
    context_access = _ import _function.context_access,
    function which _ context_access .
]
-----
free
=====
access const
-----
_ do [
    context_access = _ import _function.context_access,
    read = _ import _context.read,
    read which _ context_access .
]
-----
constant
=====
access mutable
-----
_ do [
    context_access = _ import _function.context_access,
    eval. which _ context_access .
]
-----
mutable
=====
access default
-----
_ do [
    context_access = _ import _function.context_access,
    f = _ function {},
    f which _ context_access .
]
-----
mutable
=====
is_primitive primitive
-----
_ do [
    is_primitive = _ import _function.is_primitive,
    not which _ is_primitive .
]
-----
true
=====
is_primitive composite
-----
_ do [
    is_primitive = _ import _function.is_primitive,
    f = _ function {},
    f which _ is_primitive .
]
-----
false
=====
id primitive
-----
_ do [
    id = _ import _function.id,
    not which _ id .
]
-----
bit.not
=====
id rename
-----
_ do [
    id = _ import _function.id,
    neg = not,
    neg which _ id .
]
-----
bit.not
=====
code
-----
_ do [
    code = _ import _function.code,
    f = _ function {
        code : (_ctx : _i) : _i
    },
    f which _ code .
]
-----
(ctx : i) : i
=====
ctx
-----
_ do [
    memory.new = _ import _memory.new,
    function.memory = _ import _function.memory,
    memo = _ memory.new {
        a : . : 1
    },
    f = _ function {
        memory : memo
    },
    (f which _ function.memory .) == memo
]
-----
true
=====
apply free
-----
_ do [
    apply = _ import _function.apply,
    not apply _ not true
]
-----
true
=====
apply const
-----
_ do [
    apply = _ import _function.apply,
    read = _ import _context.read,
    a = 1,
    read apply _a
]
-----
1
=====
apply mut
-----
_ do [
    apply = _ import _function.apply,
    = apply _a : 1,
    a
]
-----
1
=====
apply no adapter
-----
_ do [
    apply = _ import _function.apply,
    test apply true : [a = true] : [b = true],
    a and b
]
-----
true
=====
recurse
-----
_ do [
    recurse = _ import _function.recurse,
    g = _ function {
        code : _fi : _ do [
            (_f : _i) = _fi,
            (_i < 1) test [
                0
            ] : [
                _i + _f _f _i - 1
            ]
        ],
        context_access : _free,
    },
    g = _ recurse g,
    _ g 10
]
-----
55
