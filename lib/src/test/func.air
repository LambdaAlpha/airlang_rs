id trivial
-----
id a
-----
a
=====
id .
-----
id .a
-----
.a
=====
id *
-----
id *a
-----
*a
=====
id ^
-----
id ^a
-----
^a
=====
form. trivial
-----
form. a
-----
a
=====
form. .
-----
form. .a
-----
a
=====
form. . special
-----
form. .*a
-----
*a
=====
form. *
-----
do [a = 1, [form. *a, a]]
-----
[1, 1]
=====
form. * special
-----
do [..a = 1, [form. *.a, *.a]]
-----
[1, 1]
=====
form. ^
-----
do [a = 1, [form. ^a, is_null a]]
-----
[1, true]
=====
form. ^ special
-----
do [.*a = 1, [form. ^*a, is_null .*a]]
-----
[1, true]
=====
form* trivial
-----
do [a = 1, [form* a, a]]
-----
[1, 1]
=====
form* .
-----
form* .a
-----
a
=====
form* *
-----
do [a = 1, [form* *a, a]]
-----
[1, 1]
=====
form* ^
-----
do [a = 1, [form* ^a, is_null a]]
-----
[1, true]
=====
form^ trivial
-----
do [a = 1, [form^ a, is_null a]]
-----
[1, true]
=====
form^ .
-----
form^ .a
-----
a
=====
form^ *
-----
do [a = 1, [form^ *a, a]]
-----
[1, 1]
=====
form^ ^
-----
do [a = 1, [form^ ^a, is_null a]]
-----
[1, true]
=====
form ;
-----
form. ; a ; b
-----
a ; b
=====
form !
-----
form. ; a ! b
-----
a ! b
=====
form ?
-----
form. ; a ? b
-----
a ? b
=====
form primitive
-----
form. [a, b c]
-----
[a, b c]
=====
eval. trivial
-----
eval. a
-----
a
=====
eval. .
-----
eval. .a
-----
a
=====
eval. *
-----
do [a = 1, [eval. *a, a]]
-----
[1, 1]
=====
eval. ^
-----
do [a = 1, [eval. ^a, is_null a]]
-----
[1, true]
=====
eval* trivial
-----
do [a = 1, [eval* a, a]]
-----
[1, 1]
=====
eval* .
-----
eval* .a
-----
a
=====
eval* *
-----
do [a = 1, [eval* *a, a]]
-----
[1, 1]
=====
eval* ^
-----
do [a = 1, [eval* ^a, is_null a]]
-----
[1, true]
=====
eval^ trivial
-----
do [a = 1, [eval^ a, is_null a]]
-----
[1, true]
=====
eval^ .
-----
eval^ .a
-----
a
=====
eval^ *
-----
do [a = 1, [eval^ *a, a]]
-----
[1, 1]
=====
eval^ ^
-----
do [a = 1, [eval^ ^a, is_null a]]
-----
[1, true]
=====
mode id
-----
do [f = mode ; id, f ; .a]
-----
.a
=====
mode uni mode 1
-----
do [f = mode ; form., f ; a ; .b]
-----
a ; b
=====
mode uni mode 2
-----
do [f = mode ; eval*, f ; not ; true]
-----
false
=====
mode uni mode 3
-----
do [a = 1, f = mode ; form^, [f ; a ; .b, is_null a]]
-----
[1 ; b, true]
=====
default mode
-----
do [f = mode ; ., f ; not ; true]
-----
false
=====
mode primitive default prefix
-----
do [
    b = 1,
    f = mode ; {default : .., primitive : true},
    [f a, f *b, f ; not ; true, f [a]]
]
-----
[a, 1, false, [a]]
=====
mode primitive default eval
-----
do [
    b = 1,
    f = mode ; {default : form, primitive : true},
    [f .a, f *b, f ; .a ; b, f [b]]
]
-----
[a, 1, a ; 1, [1]]
=====
mode primitive default united
-----
do [
    b = 1,
    f = mode ; {default : eval^, primitive : true},
    [f .a, f *b, f ; 1 ; .a, f [b]]
]
-----
[a, 1, 1 ; a, [1]]
=====
mode primitive symbol id
-----
do [
    f = mode ; {symbol : id, primitive : true},
    f [^a]
]
-----
[^a]
=====
mode primitive symbol .
-----
do [
    f = mode ; {symbol : .., primitive : true},
    f [.a]
]
-----
[a]
=====
mode primitive symbol *
-----
do [
    a = 1,
    f = mode ; {symbol : .*, primitive : true},
    f [a]
]
-----
[1]
=====
mode primitive symbol ^
-----
do [
    a = 1,
    f = mode ; {symbol : .^, primitive : true},
    [f [a], is_null a]
]
-----
[[1], true]
=====
mode primitive pair id
-----
do [
    b = 1,
    f = mode ; {pair : id, primitive : true},
    f [.a : b]
]
-----
[.a : b]
=====
mode primitive pair form
-----
do [
    b = 1,
    f = mode ; {pair : form, primitive : true},
    f [.a : b]
]
-----
[a : 1]
=====
mode primitive call id
-----
do [
    f = mode ; {call : id, primitive : true},
    f [.a ; ^b]
]
-----
[.a ; ^b]
=====
mode primitive call form
-----
do [
    b = 1,
    f = mode ; {call : form, primitive : true},
    f [.a ; b]
]
-----
[a ; 1]
=====
mode primitive call eval
-----
do [
    f = mode ; {call : eval, primitive : true},
    f ; [not ; true]
]
-----
[false]
=====
mode primitive abstract id
-----
do [
    f = mode ; {abstract : id, primitive : true},
    f [.a ! ^b]
]
-----
[.a ! ^b]
=====
mode primitive abstract form
-----
do [
    b = 1,
    f = mode ; {abstract : form, primitive : true},
    f [.a ! ^b]
]
-----
[a ! 1]
=====
mode primitive abstract eval
-----
do [
    b = 1,
    f = mode ; {abstract : eval, primitive : true},
    f [.a ! b]
]
-----
[1]
=====
mode primitive ask id
-----
do [
    f = mode ; {ask : id, primitive : true},
    f [.a ? ^b]
]
-----
[.a ? ^b]
=====
mode primitive ask form
-----
do [
    b = 1,
    f = mode ; {ask : form, primitive : true},
    f [.a ? b]
]
-----
[a ? 1]
=====
mode primitive list id
-----
do [
    f = mode ; {list : id, primitive : true},
    f [a, .a, *a, ^a]
]
-----
[a, .a, *a, ^a]
=====
mode primitive list form
-----
do [
    a = 1,
    f = mode ; {list : form, primitive : true},
    f [a, .a, *a, ^a]
]
-----
[1, a, 1, 1]
=====
mode primitive map id
-----
do [
    a = 1,
    c = 2,
    f = mode ; {map : id, primitive : true},
    f {.a : *a, ^b : .a, c : d}
]
-----
{.a : *a, ^b : .a, c : d}
=====
mode primitive map form
-----
do [
    a = 1,
    b = 2,
    c = 3,
    f = mode ; {map : form, primitive : true},
    f {.a : a, b : .a, *c : .d}
]
-----
{a : 1, 2 : a, 3 : d}
=====
mode primitive multiple
-----
do [
    f = mode ; {symbol : id, call : form, default : eval^, primitive : true},
    f ; [.a, .b ; .c]
]
-----
[.a, .b ; .c]
=====
mode symbol .
-----
do [
    a = 1,
    f = mode ; {symbol : ..},
    [f a, f [a]]
]
-----
[a, [1]]
=====
mode symbol *
-----
do [
    a = 1,
    f = mode ; {symbol : .*, default : ..},
    [f a, f [a]]
]
-----
[1, [a]]
=====
mode pair united
-----
do [
    f = mode ; {pair : form.},
    a f .b
]
-----
a : b
=====
mode composite
-----
do [
    f = mode ; {pair : form. : {pair : id}},
    f ; a : .b : *c ; ^d
]
-----
a : .b : *c ; ^d
=====
mode multiple
-----
do [
    c = 1,
    d = 2,
    f = mode ; {pair : form. : {symbol : id}, default : form.},
    f ; a : .b : *c ; ^d
]
-----
a : b : 1 ; 2
=====
mode repr
-----
function.represent eval*
-----
eval*
=====
mode repr composite
-----
function.represent ; mode ; {
    symbol : id,
    pair : form. : eval*,
    list : [eval*, id],
    map : {a : eval*, b : form.} : id,
}
-----
{
    symbol : id,
    pair : form. : eval*,
    list : [eval*, id],
    map : {a : eval*, b : form.} : id : id,
}
=====
mode repr primitive
-----
function.represent ; mode ; {
    symbol : .^,
    pair : id,
    call : form,
    map : id,
    primitive : true,
}
-----
{
    symbol : ^,
    pair : id,
    call : form,
    map : id,
    primitive : true,
}
=====
recursive call
-----
do [
    f = function ; {
        body : .i,
    },
    f ; not ; true
]
-----
false
=====
body external func
-----
do [
    f = function ; {
        body : not ; .i
    },
    f ; not ; true
]
-----
true
=====
body internal func
-----
do [
    f = function ; {
        body : .not ; .i,
        context : context ; {variables :  {not : :}},
    },
    f ; not ; true
]
-----
true
=====
body rename
-----
do [
    f = function ; {
        body : .n ; .a,
        input_name : a,
        context : context ; {variables :  {n : not}},
    },
    f ; not ; true
]
-----
true
=====
body mode
-----
do [
    f = function ; {
        body_mode : form.,
        body : .i ; .*i,
    },
    f .a
]
-----
i ; a
=====
cell free
-----
do [
    f = function ; {
        body : do ; [.a = .a + 1, .a],
        context_access : free,
        cell : true,
        context : context ; {variables : {a : 0}},
    },
    [.f ., .f ., .f .]
]
-----
[1, 2, 3]
=====
cell const
-----
do [
    a = 1,
    f = function ; {
        body : do ; [.b = .b + .c | ..a, .b],
        context_access : constant,
        cell : true,
        context : context ; {variables : {
            b : 0,
        }},
    },
    [.f ., .f ., .f .]
]
-----
[1, 2, 3]
=====
cell mutable
-----
do [
    a = 1,
    f = function ; {
        body : do ; [
            .b = .b + .c | ..a,
            .c | ..a = ..a + 1,
            .b,
        ],
        context_access : mutable,
        cell : true,
        context : context ; {variables : {
            b : 0,
        }},
    },
    [.f ., .f ., .f .]
]
-----
[1, 3, 6]
=====
const const
-----
do [
    a = 1,
    f = function ; {
        body : .c | ..a,
        context_access : constant,
    },
    f .
]
-----
1
=====
mutable const
-----
do [
    a = 1,
    f = function ; {
        body : .c | ..a,
        context_access : mutable,
    },
    f .
]
-----
1
=====
mutable mutate
-----
do [
    f = function ; {
        body : .c | .i = 2,
        call_mode : id,
        context_access : mutable,
    },
    a = 1,
    f a,
    a
]
-----
2
=====
mutable mutate fail
-----
do [
    f = function ; {
        body : .c | .i = 2,
        call_mode : id,
        context_access : mutable,
    },
    (a . final) = 1,
    f a,
    a
]
-----
1
=====
const mutate fail
-----
do [
    f = function ; {
        body : .c | .i = 2,
        call_mode : id,
        context_access : constant,
    },
    a = 1,
    f a,
    a
]
-----
1
=====
const free
-----
do [
    f = function ; {
        body : 1,
        context_access : constant,
    },
    . | f ; .
]
-----
1
=====
ctx name occupied
-----
do [
    a = 1,
    f = function ; {
        context_name : ctx,
        body : 2,
        context_access : constant,
        context : context ; {variables : {ctx : 3 . .constant}},
    },
    f .,
    a == 1
]
-----
true
=====
reverse ctx
-----
do [
    a = 1,
    f = function ; {
        context_name : ctx,
        body : .ctx = 2,
        context_access : constant,
        context : context ; {reverse : true},
    },
    f .,
    a
]
-----
1
=====
repr
-----
function.represent ; function ; {body : .i}
-----
{body : i}
=====
repr primitive free
-----
function.represent not
-----
{id : not}
=====
repr const
-----
function.represent ; function ; {body : .i, context_access : constant}
-----
{body : i, context_access : constant}
=====
repr primitive const
-----
function.represent ==
-----
{id : ==}
=====
repr composite
-----
do [
    call_mode = mode ; {pair : eval* : id},
    abstract_mode = mode ; {pair : id : form.},
    ask_mode = mode ; {pair : form. : form.},
    body_mode = mode ; {list : [eval*, form., id]},
    repr = form. ; {
        body_mode : ^body_mode,
        body : in,
        input_name : in,
        context_name : ctx,
        call_mode : ^call_mode,
        abstract_mode : ^abstract_mode,
        ask_mode : ^ask_mode,
        context_access : constant,
        cacheable : true,
        cell : true,
    },
    new_repr = function.represent ; function ; repr,
    repr == new_repr
]
-----
true
=====
access free
-----
function function.context_access .
-----
free
=====
access const
-----
read function.context_access .
-----
constant
=====
access mutable
-----
eval* function.context_access .
-----
mutable
=====
access default
-----
do [f = function ; {}, f function.context_access .]
-----
mutable
=====
call mode primitive
-----
function.represent ; not function.call_mode .
-----
eval*
=====
call mode mode
-----
function.represent ; eval* function.call_mode .
-----
id
=====
call mode default
-----
do [f = function ; {}, function.represent ; f function.call_mode .]
-----
eval*
=====
call mode 1
-----
do [
    f = function ; {
        call_mode : mode ; {pair : eval* : form.},
    },
    function.represent ; f function.call_mode .
]
-----
{pair : eval* : form.}
=====
call mode 2
-----
do [
    f = function ; {
        call_mode : mode ; {list : [eval*, form., id] : form.},
    },
    function.represent ; f function.call_mode .
]
-----
{list : [eval*, form., id] : form.}
=====
call mode 3
-----
do [
    f = function ; {
        call_mode : mode ; {map : {a : eval*, b : id} : id : form.},
    },
    function.represent ; f function.call_mode .
]
-----
{map : {a : eval*, b : id} : id : form.}
=====
abstract mode
-----
do [
    f = function ; {
        abstract_mode : mode ; {map : {a : form.} : eval* : id},
    },
    function.represent ; f function.abstract_mode .
]
-----
{map : {a : form.} : eval* : id}
=====
ask mode
-----
do [
    f = function ; {
        ask_mode : mode ; {map : {a : form.} : eval* : id},
    },
    function.represent ; f function.ask_mode .
]
-----
{map : {a : form.} : eval* : id}
=====
cacheable
-----
do [f = function ; {cacheable : false}, f function.is_cacheable .]
-----
false
=====
cacheable primitive
-----
not function.is_cacheable .
-----
true
=====
is_primitive primitive
-----
not function.is_primitive .
-----
true
=====
is_primitive composite
-----
do [f = function ; {}, f function.is_primitive .]
-----
false
=====
is_extension prelude
-----
not function.is_extension .
-----
false
=====
is_cell false
-----
not function.is_cell .
-----
false
=====
is_cell true
-----
do [f = function ; {cell : true}, f function.is_cell .]
-----
true
=====
id primitive
-----
not function.id .
-----
not
=====
id rename
-----
do [neg = not, neg function.id .]
-----
not
=====
body mode
-----
do [
    f = function ; {body_mode : form.},
    function.represent ; f function.body_mode .
]
-----
form.
=====
body
-----
do [f = function ; {body : .i}, f function.body .]
-----
i
=====
ctx
-----
do [
    ctx = context ; {variables : {a : 1}},
    f = function ; {context : ctx},
    (f function.context .) == ctx
]
-----
true
=====
input name
-----
do [f = function ; {}, f function.input_name .]
-----
i
=====
ctx name
-----
do [f = function ; {context_access : constant}, f function.context_name .]
-----
c
