recursive call
-----
_ do [
    f = _ function {
        call_setup : eval@,
        code : (._ : .i) : .i,
    },
    _ f _ not true
]
-----
false
=====
call external func
-----
_ do [
    f = _ function {
        call_setup : eval@,
        code : (._ : .i) : _ not .i
    },
    _ f _ not true
]
-----
true
=====
call internal func
-----
_ do [
    f = _ function {
        call_setup : eval@,
        code : (._ : .i) : _ .not .i,
        context : _ context {not : . : not},
    },
    _ f _ not true
]
-----
true
=====
call rename
-----
_ do [
    f = _ function {
        call_setup : eval@,
        code : (._ : .a) : _ .n .a,
        context : _ context {n : . : not},
    },
    _ f _ not true
]
-----
true
=====
stateful
-----
_ do [
    f = _ function {
        context_access : .free,
        call_setup : eval@,
        code : ._ : _ do [.i = .a link.get _, .a link.set .i + 1, .i],
        context : _ context {a : . : _ link 0},
    },
    [_ f ., _ f ., _ f .]
]
-----
[0, 1, 2]
=====
multiple stateful
-----
_ do [
    f = _ form _ function {
        context_access : .free,
        call_setup : eval@,
        code : ._ : _ do [.i = .a link.get _, .a link.set .i + 1, .i],
        context : _ context {a : . : _ link 0},
    },
    f1 = $f,
    f2 = $f,
    [_ f1 ., _ f1 ., _ f1 ., _ f2 ., _ f2 ., _ f2 .]
]
-----
[0, 1, 2, 0, 1, 2]
=====
const const
-----
_ do [
    a = 1,
    f = _ function {
        code : (.c : ._) : .c ; read ..a,
        context_access : .constant,
    },
    _ f .
]
-----
1
=====
mutable const
-----
_ do [
    a = 1,
    f = _ function {
        code : (.c : ._) : .c ; read ..a,
        context_access : .mutable,
    },
    _ f .
]
-----
1
=====
mutable mutate
-----
_ do [
    f = _ function {
        code : (.c : .i) : .c ; _ .@i = 2,
        context_access : .mutable,
    },
    a = 1,
    _ f a,
    a
]
-----
2
=====
const mutate fail
-----
_ do [
    f = _ function {
        code : (.c : .i) : .c ; _ .@i = 2,
        context_access : .constant,
    },
    a = 1,
    _ f a,
    a
]
-----
1
=====
const free
-----
_ do [
    a = .,
    f = _ function {
        code : (._c : ._) : 1,
        context_access : .constant,
    },
    a ; f .
]
-----
1
=====
ctx name occupied
-----
_ do [
    a = 1,
    f = _ function {
        code : (.ctx : ._) : 2,
        context_access : .constant,
        context : _ context {ctx : constant : 3},
    },
    _ f .,
    a == 1
]
-----
true
=====
ctx explicit
-----
_ do [
    a = 1 : 2,
    f = _ function {
        call_setup : _ mode {pair : {} : {symbol : ..} : eval@},
        code : (.p : .i) : .p ; pair.set_first .i,
    },
    a ; f 3,
    a
]
-----
3 : 2
=====
repr
-----
_ function.represent _ function {code : (._ : .i) : .i}
-----
{code : (_ : i) : i}
=====
repr primitive free
-----
_ function.represent not
-----
{id : bit.not}
=====
repr const
-----
_ function.represent _ function {code : (._ : .i) : .i, context_access : .constant}
-----
{code : (_ : i) : i, context_access : constant}
=====
repr primitive const
-----
_ function.represent ==
-----
{id : ==}
=====
repr composite
-----
_ do [
    m = _ mode {pair : {} : eval@ : .},
    repr = _ form. {
        id : f,
        code : (ctx : in) : in,
        call_setup : @m,
        solve_setup : @m,
        context_access : constant,
    },
    new_repr = _ function.represent _ function repr,
    repr == new_repr
]
-----
true
=====
access free
-----
function ; function.context_access .
-----
free
=====
access const
-----
read ; function.context_access .
-----
constant
=====
access mutable
-----
eval@ ; function.context_access .
-----
mutable
=====
access default
-----
_ do [f = _ function {}, f ; function.context_access .]
-----
mutable
=====
call setup primitive
-----
eval@ == not ; function.call_setup .
-----
true
=====
call setup mode
-----
. == eval@ ; function.call_setup .
-----
true
=====
call setup 1
-----
_ do [
    f = _ function {
        call_setup : _ mode {pair : {} : eval@ : form.},
    },
    p1 = f ; function.call_setup .,
    p2 = _ mode {pair : {} : eval@ : form.},
    p1 == p2
]
-----
true
=====
call setup 2
-----
_ do [
    f = _ function {
        call_setup : _ mode {list : [eval@, form., .] : form.},
    },
    p1 = f ; function.call_setup .,
    p2 = _ mode {list : [eval@, form., .] : form.},
    p1 == p2
]
-----
true
=====
call setup 3
-----
_ do [
    f = _ function {
        call_setup : _ mode {map : {a : eval@, b : .} : . : form.},
    },
    p1 = f ; function.call_setup .,
    p2 = _ mode {map : {a : eval@, b : .} : . : form.},
    p1 == p2
]
-----
true
=====
solve setup
-----
eval@ == not ; function.solve_setup .
-----
true
=====
is_primitive primitive
-----
not ; function.is_primitive .
-----
true
=====
is_primitive composite
-----
_ do [f = _ function {}, f ; function.is_primitive .]
-----
false
=====
id primitive
-----
not ; function.id .
-----
bit.not
=====
id rename
-----
_ do [neg = not, neg ; function.id .]
-----
bit.not
=====
code
-----
_ do [f = _ function {code : (.ctx : .i) : .i}, f ; function.code .]
-----
(ctx : i) : i
=====
ctx
-----
_ do [
    ctx = _ context {a : . : 1},
    f = _ function {context : ctx},
    (f ; function.context .) == ctx
]
-----
true
