get_length push
-----
_ do [
    .any set _ import _value.any,
    .get_length set _ import _list.get_length,
    .push set _ import _list.push,
    .a set _ any _list,
    .l1 set .a which get_length : .,
    .a which push : .,
    .l2 set .a which get_length : .,
    l2 == l1 + 1
]
-----
true
=====
get_length push_many
-----
_ do [
    .any set _ import _value.any,
    .get_length set _ import _list.get_length,
    .push_many set _ import _list.push_many,
    .a set _ any _list,
    .la set .a which get_length : .,
    .b set _ any _list,
    .lb set .b which get_length : .,
    .a which push_many : b,
    .lab set .a which get_length : .,
    lab == la + lb
]
-----
true
=====
get_length pop_many
-----
_ do [
    .any set _ import _value.any,
    .get_length set _ import _list.get_length,
    .pop_many set _ import _list.pop_many,
    .% set _ import _integer.remainder,
    .a set _ any _list,
    .l1 set .a which get_length : .,
    (l1 == 0) _return true,
    .i set (l1 + (_ any _integer) % l1) % l1,
    .a which pop_many : i,
    .l2 set .a which get_length : .,
    l2 == l1 - i
]
-----
true
=====
set get
-----
_ do [
    .any set _ import _value.any,
    .get_length set _ import _list.get_length,
    .list.set set _ import _list.set,
    .list.get set _ import _list.get,
    .% set _ import _integer.remainder,
    .a set _ any _list,
    .b set a,
    .l set .a which get_length : .,
    (l == 0) _return true,
    .i set (l + (_ any _integer) % l) % l,
    .v1 set .a which list.get : i,
    .v2 set _ any .,
    .v3 set .a which list.set : i : v2,
    .v4 set .a which list.get : i,
    .a which list.set : i : v1,
    (v1 == v3) and (v2 == v4) and (a == b)
]
-----
true
=====
set_many get_many
-----
_ do [
    .any set _ import _value.any,
    .get_length set _ import _list.get_length,
    .get_many set _ import _list.get_many,
    .set_many set _ import _list.set_many,
    .% set _ import _integer.remainder,
    .a set _ any _list,
    .la set .a which get_length : .,
    (la == 0) _return true,
    .b set _ any _list,
    .lb set .b which get_length : .,
    (lb == 0) _return true,
    (la < lb) test [
        .t set a,
        .a set b,
        .b set t,
        .t set la,
        .la set lb,
        .lb set t,
    ] : [],
    .a1 set a,
    .d set la - lb,
    .i set (d == 0) test [0] : [(d + (_ any _integer) % d) % d],
    .c1 set .a which get_many : i : i + lb,
    .c2 set .a which set_many : i : b,
    .b1 set .a which get_many : i : i + lb,
    .a which set_many : i : c1,
    (b == b1) and (c1 == c2) and (a == a1)
]
-----
true
=====
insert get get_length
-----
_ do [
    .any set _ import _value.any,
    .get_length set _ import _list.get_length,
    .insert set _ import _list.insert,
    .get set _ import _list.get,
    .% set _ import _integer.remainder,
    .a set _ any _list,
    .l set 1 + .a which get_length : .,
    .i set (l + (_ any _integer) % l) % l,
    .v set _ any .,
    .a which insert : i : v,
    .v1 set .a which get : i,
    .l1 set .a which get_length : .,
    (v == v1) and (l == l1)
]
-----
true
=====
insert remove
-----
_ do [
    .any set _ import _value.any,
    .get_length set _ import _list.get_length,
    .insert set _ import _list.insert,
    .remove set _ import _list.remove,
    .% set _ import _integer.remainder,
    .a set _ any _list,
    .b set a,
    .l set 1 + .a which get_length : .,
    .i set (l + (_ any _integer) % l) % l,
    .v1 set _ any .,
    .a which insert : i : v1,
    .v2 set .a which remove : i,
    (v1 == v2) and a == b
]
-----
true
=====
insert_many get_many get_length
-----
_ do [
    .any set _ import _value.any,
    .get_length set _ import _list.get_length,
    .insert_many set _ import _list.insert_many,
    .get_many set _ import _list.get_many,
    .% set _ import _integer.remainder,
    .a set _ any _list,
    .l1 set 1 + .a which get_length : .,
    .i set (l1 + (_ any _integer) % l1) % l1,
    .v1 set _ any _list,
    .vl set .v1 which get_length : .,
    .a which insert_many : i : v1,
    .v2 set .a which get_many : i : i + vl,
    .l2 set .a which get_length : .,
    (v1 == v2) and l2 == l1 + vl - 1,
]
-----
true
=====
insert_many remove_many
-----
_ do [
    .any set _ import _value.any,
    .get_length set _ import _list.get_length,
    .insert_many set _ import _list.insert_many,
    .remove_many set _ import _list.remove_many,
    .% set _ import _integer.remainder,
    .a set _ any _list,
    .b set a,
    .l set 1 + .a which get_length : .,
    .i set (l + (_ any _integer) % l) % l,
    .v1 set _ any _list,
    .v1l set .v1 which get_length : .,
    .a which insert_many : i : v1,
    .v2 set .a which remove_many : i : i + v1l,
    (v1 == v2) and a == b
]
-----
true
=====
push pop
-----
_ do [
    .any set _ import _value.any,
    .push set _ import _list.push,
    .pop set _ import _list.pop,
    .a1 set _ any _list,
    .a2 set a1,
    .v1 set _ any .,
    .a1 which push : v1,
    .v2 set .a1 which pop : .,
    (v1 == v2) and (a1 == a2)
]
-----
true
=====
push_many pop_many
-----
_ do [
    .any set _ import _value.any,
    .get_length set _ import _list.get_length,
    .push_many set _ import _list.push_many,
    .pop_many set _ import _list.pop_many,
    .a1 set _ any _list,
    .a2 set a1,
    .b1 set _ any _list,
    .lb set .b1 which get_length : .,
    .a1 which push_many : b1,
    .b2 set .a1 which pop_many : lb,
    (b1 == b2) and a1 == a2
]
-----
true
=====
clear
-----
_ do [
    .any set _ import _value.any,
    .clear set _ import _list.clear,
    .a set _ any _list,
    .a which clear : .,
    a == []
]
-----
true
=====
get_length empty
-----
_ do [
    .get_length set _ import _list.get_length,
    .l set [],
    .l which get_length : .
]
-----
0
=====
get_length else
-----
_ do [
    .get_length set _ import _list.get_length,
    .l set [1, 2],
    .l which get_length : .
]
-----
2
=====
set 1
-----
_ do [
    .list.set set _ import _list.set,
    .a set [1],
    .a which list.set : 0 : 2,
    a
]
-----
[2]
=====
set 2
-----
_ do [
    .list.set set _ import _list.set,
    .a set [1, 2],
    .a which list.set : 1 : 3,
    a
]
-----
[1, 3]
=====
set length
-----
_ do [
    .list.set set _ import _list.set,
    .config.new set _ import _config.new,
    .link.new set _ import _link.new,
    .where set _ import _config.where,
    .is_aborted set _ import _error.is_aborted,
    .c set _ config.new {
        _prelude : _ link.new {
            do : do,
            set : set,
            which : which,
            list.set : list.set,
        },
    },
    c where _ do [
        .a set [],
        .a which list.set : 1 : 1,
    ],
    .c which is_aborted : .,
]
-----
true
=====
set_many empty
-----
_ do [
    .set_many set _ import _list.set_many,
    .a set [0, 1, 2],
    .a which set_many : 0 : []
]
-----
[]
=====
set_many 1
-----
_ do [
    .set_many set _ import _list.set_many,
    .a set [0, 1, 2],
    .a which set_many : 0 : [3, 4],
    a
]
-----
[3, 4, 2]
=====
set_many 2
-----
_ do [
    .set_many set _ import _list.set_many,
    .a set [0, 1, 2],
    .a which set_many : 1 : [3, 4],
    a
]
-----
[0, 3, 4]
=====
set_many last
-----
_ do [
    .set_many set _ import _list.set_many,
    .a set [0, 1, 2],
    .a which set_many : 2 : [],
    a
]
-----
[0, 1, 2]
=====
get out of bound
-----
_ do [
    .list.get set _ import _list.get,
    .config.new set _ import _config.new,
    .link.new set _ import _link.new,
    .where set _ import _config.where,
    .is_aborted set _ import _error.is_aborted,
    .c set _ config.new {
        _prelude : _ link.new {
            do : do,
            set : set,
            which : which,
            list.get : list.get,
        },
    },
    c where _ do [
        .l set [],
        .l which list.get : 0
    ],
    .c which is_aborted : .,
]
-----
true
=====
get 0
-----
_ do [
    .get set _ import _list.get,
    .l set [1],
    .l which get : 0
]
-----
1
=====
get else
-----
_ do [
    .get set _ import _list.get,
    .l set [1, 2],
    .l which get : 1
]
-----
2
=====
get_many 1
-----
_ do [
    .get_many set _ import _list.get_many,
    .l set [1, 2],
    .l which get_many : 0 : 1
]
-----
[1]
=====
get_many 2
-----
_ do [
    .get_many set _ import _list.get_many,
    .l set [1, 2],
    .l which get_many : 1 : 2
]
-----
[2]
=====
get_many . 1
-----
_ do [
    .get_many set _ import _list.get_many,
    .l set [1, 2],
    .l which get_many : . : .
]
-----
[1, 2]
=====
get_many . 2
-----
_ do [
    .get_many set _ import _list.get_many,
    .l set [1, 2],
    .l which get_many : 1 : .
]
-----
[2]
=====
get_many . 3
-----
_ do [
    .get_many set _ import _list.get_many,
    .l set [1, 2],
    .l which get_many : . : 1
]
-----
[1]
=====
insert out of bound
-----
_ do [
    .insert set _ import _list.insert,
    .config.new set _ import _config.new,
    .link.new set _ import _link.new,
    .where set _ import _config.where,
    .is_aborted set _ import _error.is_aborted,
    .c set _ config.new {
        _prelude : _ link.new {
            do : do,
            set : set,
            which : which,
            insert : insert,
        },
    },
    c where _ do [
        .l set [],
        .l which insert : 1 : 1,
    ],
    .c which is_aborted : .,
]
-----
true
=====
insert
-----
_ do [
    .insert set _ import _list.insert,
    .l set [1, 2],
    .l which insert : 1 : 3,
    l
]
-----
[1, 3, 2]
=====
insert length
-----
_ do [
    .insert set _ import _list.insert,
    .a set [],
    .a which insert : 0 : 1,
    a
]
-----
[1]
=====
insert_many
-----
_ do [
    .insert_many set _ import _list.insert_many,
    .l set [1, 2],
    .l which insert_many : 1 : [3, 4],
    l
]
-----
[1, 3, 4, 2]
=====
remove
-----
_ do [
    .remove set _ import _list.remove,
    .l set [1, 2, 3],
    [.l which remove : 1, l]
]
-----
[2, [1, 3]]
=====
remove_many
-----
_ do [
    .remove_many set _ import _list.remove_many,
    .l set [1, 2, 3],
    [.l which remove_many : 1 : 3, l]
]
-----
[[2, 3], [1]]
=====
remove_many .
-----
_ do [
    .remove_many set _ import _list.remove_many,
    .l set [1, 2, 3],
    .l which remove_many : . : .,
    l
]
-----
[]
=====
push
-----
_ do [
    .push set _ import _list.push,
    .l set [1],
    .l which push : 2,
    l
]
-----
[1, 2]
=====
push_many
-----
_ do [
    .push_many set _ import _list.push_many,
    .l set [1],
    .l which push_many : [2, 3],
    l
]
-----
[1, 2, 3]
=====
push_many empty
-----
_ do [
    .push_many set _ import _list.push_many,
    .l set [1],
    .l which push_many : [],
    l
]
-----
[1]
=====
pop empty
-----
_ do [
    .pop set _ import _list.pop,
    .config.new set _ import _config.new,
    .link.new set _ import _link.new,
    .where set _ import _config.where,
    .is_aborted set _ import _error.is_aborted,
    .c set _ config.new {
        _prelude : _ link.new {
            do : do,
            set : set,
            which : which,
            pop : pop,
        },
    },
    c where _ do [
        .l set [],
        .l which pop : .,
    ],
    .c which is_aborted : .,
]
-----
true
=====
pop 1
-----
_ do [
    .pop set _ import _list.pop,
    .l set [1],
    [.l which pop : ., l]
]
-----
[1, []]
=====
pop 2
-----
_ do [
    .pop set _ import _list.pop,
    .l set [1, 2],
    [.l which pop : ., l]
]
-----
[2, [1]]
=====
pop_many 0
-----
_ do [
    .pop_many set _ import _list.pop_many,
    .l set [1, 2],
    [.l which pop_many : 0, l]
]
-----
[[], [1, 2]]
=====
pop_many 1
-----
_ do [
    .pop_many set _ import _list.pop_many,
    .l set [1, 2],
    [.l which pop_many : 1, l]
]
-----
[[2], [1]]
=====
pop_many else
-----
_ do [
    .pop_many set _ import _list.pop_many,
    .l set [1, 2],
    [.l which pop_many : 2, l]
]
-----
[[1, 2], []]
=====
pop_many out of bound
-----
_ do [
    .pop_many set _ import _list.pop_many,
    .config.new set _ import _config.new,
    .link.new set _ import _link.new,
    .where set _ import _config.where,
    .is_aborted set _ import _error.is_aborted,
    .c set _ config.new {
        _prelude : _ link.new {
            do : do,
            set : set,
            which : which,
            pop_many : pop_many,
        },
    },
    c where _ do [
        .l set [1, 2],
        .l which pop_many : 3,
    ],
    .c which is_aborted : .,
]
-----
true
=====
clear
-----
_ do [
    .clear set _ import _list.clear,
    .l set [1, 2],
    .l which clear : .,
    l
]
-----
[]
