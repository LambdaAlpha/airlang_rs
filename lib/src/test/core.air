atom
-----
true
-----
true
=====
assign and read
-----
_ do [a = 1, a]
-----
1
=====
symbol literal
-----
.a
-----
a
=====
symbol literal special 1
-----
..a
-----
.a
=====
symbol literal special 2
-----
...a
-----
..a
=====
symbol literal special 3
-----
.@a
-----
@a
=====
ctx ref
-----
_ do [a = 1, @a]
-----
1
=====
ref will not remove
-----
_ do [a = 1, @a, a]
-----
1
=====
ref special
-----
_ do [..a = 1, @.a]
-----
1
=====
pair ref
-----
_ do [p = 1 : 2, p ; do [first : second]]
-----
1 : 2
=====
task ref func
-----
_ do [t = _ form ctx ; func input, t ; do [context : function : input]]
-----
ctx : func : input
=====
list ref
-----
_ do [l = [0, 3, 6], l ; do [@0 : @1 : @2]]
-----
0 : 3 : 6
=====
map ref
-----
_ do [m = {a : 1, b : 2}, m ; do [a : b]]
-----
1 : 2
=====
eval
-----
_ do [a = _ form _ not true, $a]
-----
false
=====
pair eval
-----
(_ not false) : "1"
-----
true : "1"
=====
list eval
-----
[_ not true, 1, "2"]
-----
[false, 1, "2"]
=====
map eval
-----
{(_ not true) : (_ not true)}
-----
{(_ not true) : false}
=====
call recursive
-----
_ not _ not true
-----
true
=====
ctx unit
-----
_ do [a = 1, . ; apply .a]
-----
1
=====
ctx ctx name
-----
_ do [p = 1 : 2, p ; pair.first .]
-----
1
=====
pair ctx first
-----
_ do [p = 1 : 2, p ; apply .first ; self .]
-----
1
=====
pair ctx first
-----
_ do [p = 1 : 2, p ; apply .second ; self .]
-----
2
=====
task ctx func
-----
_ do [t = _ form ctx ; func input, t ; apply .function ; self .]
-----
func
=====
task ctx ctx
-----
_ do [t = _ form ctx ; func input, t ; apply .context ; self .]
-----
ctx
=====
task ctx input
-----
_ do [t = _ form ctx ; func input, t ; apply .input ; self .]
-----
input
=====
list ctx index int
-----
_ do [l = [0, 2, 4], l ; apply 1 ; self .]
-----
2
=====
list ctx index symbol
-----
_ do [l = [0, 2, 4], l ; apply .1 ; self .]
-----
2
=====
map ctx key
-----
_ do [m = {a : 1, b : 2}, m ; apply .a ; self .]
-----
1
=====
map ctx key .
-----
_ do [m = {a : 1, b : 2}, m ; apply . ; self .]
-----
{a : 1, b : 2}
=====
map ctx key other
-----
_ do [m = {1 : 2, 2 : 4}, m ; apply 1 ; self .]
-----
2
=====
cell ctx
-----
_ do [
    f = _ function {
        code : ._ : _ do [.a = .a + 1, .a],
        context_access : .free,
        cell : true,
        context : _ context {a : . : 0},
    },
    [_ .f ., _ .f ., _ .f .]
]
-----
[1, 2, 3]
=====
cell pair
-----
_ do [
    p = . : _ function {
        code : ._ : _ do [.a = .a + 1, .a],
        cell : true,
        context_access : .free,
        context : _ context {a : . : 0},
    },
    [p ; do [_ .second .], p ; do [_ .second .], p ; do [_ .second .]]
]
-----
[1, 2, 3]
=====
cell task
-----
_ do [
    f = _ function {
        code : ._ : _ do [.a = .a + 1, .a],
        cell : true,
        context_access : .free,
        context : _ context {a : . : 0},
    },
    t = _ form. ctx ; func @f, 
    [t ; do [_ .input .], t ; do [_ .input .], t ; do [_ .input .]]
]
-----
[1, 2, 3]
=====
cell list
-----
_ do [
    l = [1, _ function {
        code : ._ : _ do [.a = .a + 1, .a],
        cell : true,
        context_access : .free,
        context : _ context {a : . : 0},
    }],
    [l ; do [_ .1 .], l ; do [_ .1 .], l ; do [_ .1 .]]
]
-----
[1, 2, 3]
=====
cell map
-----
_ do [
    m = {a, b : _ function {
        code : ._ : _ do [.a = .a + 1, .a],
        cell : true,
        context_access : .free,
        context : _ context {a : . : 0},
    }},
    [m ; do [_ .b .], m ; do [_ .b .], m ; do [_ .b .]]
]
-----
[1, 2, 3]
