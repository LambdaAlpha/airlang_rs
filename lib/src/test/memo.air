length
-----
_ do [
    _length set _ import _memory.length,
    _new set _ import _memory.new,
    _any set _ import _value.any,
    _m set _ new {
        a : . : _ any .,
        b : . : _ any .,
        c : . : _ any .,
        d : . : _ any .,
    },
    m which _ length _
]
-----
4
=====
length == repr length
-----
_ do [
    _memory.length set _ import _memory.length,
    _map.length set _ import _map.length,
    _represent set _ import _memory.represent,
    _any set _ import _value.any,
    _m set _ any _memory,
    _m1 set _ represent m,
    _l set m which _ memory.length _,
    _l1 set m1 which _ map.length _,
    l == l1
]
-----
true
=====
get none
-----
_ do [
    _any set _ import _value.any,
    _a set _ any .,
    a == _a get _
]
-----
true
=====
get final
-----
_ do [
    _any set _ import _value.any,
    _new set _ import _memory.new,
    _v set _ any .,
    _a set _ new {b : final : v},
    v == a which _ get _b
]
-----
true
=====
get still
-----
_ do [
    _any set _ import _value.any,
    _new set _ import _memory.new,
    _v set _ any .,
    _a set _ new {b : still : v},
    v == a which _ get _b
]
-----
true
=====
get static
-----
_ do [
    _any set _ import _value.any,
    _new set _ import _memory.new,
    _v set _ any .,
    _a set _ new {b : static : v},
    v == a which _ get _b
]
-----
true
=====
get const
-----
_ do [
    _any set _ import _value.any,
    _new set _ import _memory.new,
    _v set _ any .,
    _a set _ new {b : constant : v},
    v == a which _ get _b
]
-----
true
=====
move ref
-----
_ do [
    _any set _ import _value.any,
    _exist set _ import _memory.exist,
    _a set _ any .,
    _b set a,
    (b == _a move _) and (_ not _a exist _)
]
-----
true
=====
move indirect
-----
_ do [
    _any set _ import _value.any,
    _exist set _ import _memory.exist,
    _a set _ any .,
    _b set _a,
    _c set a,
    (c == b move _) and (_ not _a exist _)
]
-----
true
=====
move final
-----
_ do [
    _any set _ import _value.any,
    _new set _ import _memory.new,
    _exist set _ import _memory.exist,
    _v set _ any .,
    _a set _ new {b : final : v},
    (. == a which _ move _b) and (a which _ exist _b)
]
-----
true
=====
move still
-----
_ do [
    _any set _ import _value.any,
    _new set _ import _memory.new,
    _exist set _ import _memory.exist,
    _v set _ any .,
    _a set _ new {b : still : v},
    (v == a which _ move _b) and (_ not a which _ exist _b)
]
-----
true
=====
move static
-----
_ do [
    _any set _ import _value.any,
    _new set _ import _memory.new,
    _exist set _ import _memory.exist,
    _v set _ any .,
    _a set _ new {b : static : v},
    (. == a which _ move _b) and (a which _ exist _b)
]
-----
true
=====
move const
-----
_ do [
    _any set _ import _value.any,
    _new set _ import _memory.new,
    _exist set _ import _memory.exist,
    _v set _ any .,
    _a set _ new {b : constant : v},
    (. == a which _ move _b) and (a which _ exist _b)
]
-----
true
=====
= none
-----
_ do [
    _contract set _ import _memory.contract,
    _a set 1,
    [a, _a contract _]
]
-----
[1, none]
=====
= const
-----
_ do [
    _set_contract set _ import _memory.set_contract,
    _first set _ import _pair.first,
    _p set 1 : 2,
    _p set_contract _final,
    p which _first set 3,
    p which _ first .
]
-----
1
=====
_none set return
-----
_ do [
    _any set _ import _value.any,
    _a set 1,
    1 == _a set _ any .
]
-----
true
=====
none mutate
-----
_ do [
    _set_first set _ import _pair.set_first,
    _a set 1 : 2,
    a which _ set_first 3,
    a
]
-----
3 : 2
=====
final mutate
-----
_ do [
    _any set _ import _value.any,
    _set_contract set _ import _memory.set_contract,
    _set_first set _ import _pair.set_first,
    _a set 1 : 2,
    _a set_contract _final,
    a which _ set_first _ any .,
    a
]
-----
1 : 2
=====
final =
-----
_ do [
    _any set _ import _value.any,
    _set_contract set _ import _memory.set_contract,
    _final_a set 1,
    _final_a set_contract _final,
    _final_a set _ any .,
    final_a
]
-----
1
=====
set_contract still none
-----
_ do [
    _any set _ import _value.any,
    _new set _ import _memory.new,
    _set_contract set _ import _memory.set_contract,
    _contract set _ import _memory.contract,
    _c set _ new {a : still : _ any .},
    c which _a set_contract _none,
    c which _ contract _a
]
-----
none
=====
set_contract still none
-----
_ do [
    _any set _ import _value.any,
    _new set _ import _memory.new,
    _set_contract set _ import _memory.set_contract,
    _contract set _ import _memory.contract,
    _c set _ new {a : still : _ any .},
    c which _a set_contract _final,
    c which _ contract _a
]
-----
final
=====
set_contract none final
-----
_ do [
    _any set _ import _value.any,
    _set_contract set _ import _memory.set_contract,
    _contract set _ import _memory.contract,
    _a set _ any .,
    _a set_contract _final,
    _a contract _
]
-----
final
=====
set_contract none still
-----
_ do [
    _any set _ import _value.any,
    _set_contract set _ import _memory.set_contract,
    _contract set _ import _memory.contract,
    _a set _ any .,
    _a set_contract _still,
    _a contract _
]
-----
none
=====
set_contract final still
-----
_ do [
    _any set _ import _value.any,
    _new set _ import _memory.new,
    _set_contract set _ import _memory.set_contract,
    _contract set _ import _memory.contract,
    _c set _ new {a : final : _ any .},
    c which _a set_contract _still,
    c which _ contract _a
]
-----
final
=====
set_contract final none
-----
_ do [
    _any set _ import _value.any,
    _new set _ import _memory.new,
    _set_contract set _ import _memory.set_contract,
    _contract set _ import _memory.contract,
    _c set _ new {a : final : _ any .},
    c which _a set_contract _none,
    c which _ contract _a
]
-----
final
=====
set_contract static const
-----
_ do [
    _any set _ import _value.any,
    _new set _ import _memory.new,
    _set_contract set _ import _memory.set_contract,
    _contract set _ import _memory.contract,
    _c set _ new {a : static : _ any .},
    c which _a set_contract _constant,
    c which _ contract _a
]
-----
static
=====
set_contract static still
-----
_ do [
    _any set _ import _value.any,
    _new set _ import _memory.new,
    _set_contract set _ import _memory.set_contract,
    _contract set _ import _memory.contract,
    _c set _ new {a : static : _ any .},
    c which _a set_contract _still,
    c which _ contract _a
]
-----
static
=====
set_contract static final
-----
_ do [
    _any set _ import _value.any,
    _new set _ import _memory.new,
    _set_contract set _ import _memory.set_contract,
    _contract set _ import _memory.contract,
    _c set _ new {a : static : _ any .},
    c which _a set_contract _final,
    c which _ contract _a
]
-----
static
=====
set_contract static none
-----
_ do [
    _any set _ import _value.any,
    _new set _ import _memory.new,
    _set_contract set _ import _memory.set_contract,
    _contract set _ import _memory.contract,
    _c set _ new {a : static : _ any .},
    c which _a set_contract _none,
    c which _ contract _a
]
-----
static
=====
exist false
-----
_ do [
    _exist set _ import _memory.exist,
    _a exist _
]
-----
false
=====
exist true
-----
_ do [
    _any set _ import _value.any,
    _exist set _ import _memory.exist,
    _a set _ any .,
    _a exist _
]
-----
true
=====
static move
-----
_ do [
    _new set _ import _memory.new,
    _c set _ new {a : static : 1},
    c which _ move _a,
    c which _ get _a
]
-----
1
=====
static set to static
-----
_ do [
    _new set _ import _memory.new,
    _c set _ new {static_a : static : 1},
    c which _static_a set 2,
    c which _ get _static_a
]
-----
1
=====
which free free
-----
_ do [
    _u set .,
    u which 1 + 1
]
-----
2
=====
which free mutate
-----
_ do [
    _u set .,
    _a set 1,
    u which _ move _a,
    a
]
-----
1
=====
represent default
-----
_ do [
    _new set _ import _memory.new,
    _represent set _ import _memory.represent,
    _ represent _ new {}
]
-----
{}
=====
represent else
-----
_ do [
    _new set _ import _memory.new,
    _represent set _ import _memory.represent,
    _ represent _ new {a : constant : 1}
]
-----
{a : constant : 1}
=====
represent non-recursive
-----
_ do [
    _new set _ import _memory.new,
    _represent set _ import _memory.represent,
    _remove set _ import _map.remove,
    _second set _ import _pair.second,
    _m set _ represent _ new {b : . : _ new {}},
    _b set m which _ remove _b,
    _b set b which _ second .,
    b which _ type .
]
-----
memory
=====
reverse
-----
_ do [
    _new set _ import _memory.new,
    _reverse set _ import _memory.reverse,
    _c1 set _ new {
        a : none : 1,
        b : still : 2,
        c : final : 3,
        d : static : 4,
        e : constant : 5,
    },
    _c2 set _ new {
        a : none : 1,
        b : final : 2,
        c : still : 3,
        d : static : 4,
        e : constant : 5,
    },
    (c1 == _ reverse c2) and (c2 == _ reverse c1)
]
-----
true
