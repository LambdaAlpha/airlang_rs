length
-----
_ do [
    length = _ import _memory.length,
    new = _ import _memory.new,
    any = _ import _value.any,
    m = _ new {
        a : . : _ any .,
        b : . : _ any .,
        c : . : _ any .,
        d : . : _ any .,
    },
    m which _ length _
]
-----
4
=====
length == repr length
-----
_ do [
    memory.length = _ import _memory.length,
    map.length = _ import _map.length,
    represent = _ import _memory.represent,
    any = _ import _value.any,
    m = _ any memory,
    m1 = _ represent m,
    l = m which _ memory.length _,
    l1 = m1 which _ map.length _,
    l == l1
]
-----
true
=====
get none
-----
_ do [
    any = _ import _value.any,
    a = _ any .,
    a == _a get _
]
-----
true
=====
get final
-----
_ do [
    any = _ import _value.any,
    new = _ import _memory.new,
    v = _ any .,
    a = _ new {b : final : v},
    v == a which _ get _b
]
-----
true
=====
get still
-----
_ do [
    any = _ import _value.any,
    new = _ import _memory.new,
    v = _ any .,
    a = _ new {b : still : v},
    v == a which _ get _b
]
-----
true
=====
get static
-----
_ do [
    any = _ import _value.any,
    new = _ import _memory.new,
    v = _ any .,
    a = _ new {b : static : v},
    v == a which _ get _b
]
-----
true
=====
get const
-----
_ do [
    any = _ import _value.any,
    new = _ import _memory.new,
    v = _ any .,
    a = _ new {b : constant : v},
    v == a which _ get _b
]
-----
true
=====
move ref
-----
_ do [
    any = _ import _value.any,
    exist = _ import _memory.exist,
    a = _ any .,
    b = a,
    (b == _a move _) and (_ not _a exist _)
]
-----
true
=====
move indirect
-----
_ do [
    any = _ import _value.any,
    exist = _ import _memory.exist,
    a = _ any .,
    b = _a,
    c = a,
    (c == b move _) and (_ not _a exist _)
]
-----
true
=====
move final
-----
_ do [
    any = _ import _value.any,
    new = _ import _memory.new,
    exist = _ import _memory.exist,
    v = _ any .,
    a = _ new {b : final : v},
    (. == a which _ move _b) and (a which _ exist _b)
]
-----
true
=====
move still
-----
_ do [
    any = _ import _value.any,
    new = _ import _memory.new,
    exist = _ import _memory.exist,
    v = _ any .,
    a = _ new {b : still : v},
    (v == a which _ move _b) and (_ not a which _ exist _b)
]
-----
true
=====
move static
-----
_ do [
    any = _ import _value.any,
    new = _ import _memory.new,
    exist = _ import _memory.exist,
    v = _ any .,
    a = _ new {b : static : v},
    (. == a which _ move _b) and (a which _ exist _b)
]
-----
true
=====
move const
-----
_ do [
    any = _ import _value.any,
    new = _ import _memory.new,
    exist = _ import _memory.exist,
    v = _ any .,
    a = _ new {b : constant : v},
    (. == a which _ move _b) and (a which _ exist _b)
]
-----
true
=====
= none
-----
_ do [
    contract = _ import _memory.contract,
    a = 1,
    [a, _a contract _]
]
-----
[1, none]
=====
= const
-----
_ do [
    set_contract = _ import _memory.set_contract,
    first = _ import _pair.first,
    p = 1 : 2,
    _p set_contract _final,
    p which first = 3,
    p which _ first .
]
-----
1
=====
none = return
-----
_ do [
    any = _ import _value.any,
    a = 1,
    1 == a = _ any .
]
-----
true
=====
none mutate
-----
_ do [
    set_first = _ import _pair.set_first,
    a = 1 : 2,
    a which _ set_first 3,
    a
]
-----
3 : 2
=====
final mutate
-----
_ do [
    any = _ import _value.any,
    set_contract = _ import _memory.set_contract,
    set_first = _ import _pair.set_first,
    a = 1 : 2,
    _a set_contract _final,
    a which _ set_first _ any .,
    a
]
-----
1 : 2
=====
final =
-----
_ do [
    any = _ import _value.any,
    set_contract = _ import _memory.set_contract,
    final_a = 1,
    _final_a set_contract _final,
    final_a = _ any .,
    final_a
]
-----
1
=====
set_contract still none
-----
_ do [
    any = _ import _value.any,
    new = _ import _memory.new,
    set_contract = _ import _memory.set_contract,
    contract = _ import _memory.contract,
    c = _ new {a : still : _ any .},
    c which _a set_contract _none,
    c which _ contract _a
]
-----
none
=====
set_contract still none
-----
_ do [
    any = _ import _value.any,
    new = _ import _memory.new,
    set_contract = _ import _memory.set_contract,
    contract = _ import _memory.contract,
    c = _ new {a : still : _ any .},
    c which _a set_contract _final,
    c which _ contract _a
]
-----
final
=====
set_contract none final
-----
_ do [
    any = _ import _value.any,
    set_contract = _ import _memory.set_contract,
    contract = _ import _memory.contract,
    a = _ any .,
    _a set_contract _final,
    _a contract _
]
-----
final
=====
set_contract none still
-----
_ do [
    any = _ import _value.any,
    set_contract = _ import _memory.set_contract,
    contract = _ import _memory.contract,
    a = _ any .,
    _a set_contract _still,
    _a contract _
]
-----
none
=====
set_contract final still
-----
_ do [
    any = _ import _value.any,
    new = _ import _memory.new,
    set_contract = _ import _memory.set_contract,
    contract = _ import _memory.contract,
    c = _ new {a : final : _ any .},
    c which _a set_contract _still,
    c which _ contract _a
]
-----
final
=====
set_contract final none
-----
_ do [
    any = _ import _value.any,
    new = _ import _memory.new,
    set_contract = _ import _memory.set_contract,
    contract = _ import _memory.contract,
    c = _ new {a : final : _ any .},
    c which _a set_contract _none,
    c which _ contract _a
]
-----
final
=====
set_contract static const
-----
_ do [
    any = _ import _value.any,
    new = _ import _memory.new,
    set_contract = _ import _memory.set_contract,
    contract = _ import _memory.contract,
    c = _ new {a : static : _ any .},
    c which _a set_contract _constant,
    c which _ contract _a
]
-----
static
=====
set_contract static still
-----
_ do [
    any = _ import _value.any,
    new = _ import _memory.new,
    set_contract = _ import _memory.set_contract,
    contract = _ import _memory.contract,
    c = _ new {a : static : _ any .},
    c which _a set_contract _still,
    c which _ contract _a
]
-----
static
=====
set_contract static final
-----
_ do [
    any = _ import _value.any,
    new = _ import _memory.new,
    set_contract = _ import _memory.set_contract,
    contract = _ import _memory.contract,
    c = _ new {a : static : _ any .},
    c which _a set_contract _final,
    c which _ contract _a
]
-----
static
=====
set_contract static none
-----
_ do [
    any = _ import _value.any,
    new = _ import _memory.new,
    set_contract = _ import _memory.set_contract,
    contract = _ import _memory.contract,
    c = _ new {a : static : _ any .},
    c which _a set_contract _none,
    c which _ contract _a
]
-----
static
=====
exist false
-----
_ do [
    exist = _ import _memory.exist,
    _a exist _
]
-----
false
=====
exist true
-----
_ do [
    any = _ import _value.any,
    exist = _ import _memory.exist,
    a = _ any .,
    _a exist _
]
-----
true
=====
static move
-----
_ do [
    new = _ import _memory.new,
    c = _ new {a : static : 1},
    c which _ move _a,
    c which _ get _a
]
-----
1
=====
static = to static
-----
_ do [
    new = _ import _memory.new,
    c = _ new {static_a : static : 1},
    c which static_a = 2,
    c which _ get _static_a
]
-----
1
=====
which free free
-----
_ do [
    u = .,
    u which 1 + 1
]
-----
2
=====
which free mutate
-----
_ do [
    u = .,
    a = 1,
    u which _ move _a,
    a
]
-----
1
=====
represent default
-----
_ do [
    new = _ import _memory.new,
    represent = _ import _memory.represent,
    _ represent _ new {}
]
-----
{}
=====
represent else
-----
_ do [
    new = _ import _memory.new,
    represent = _ import _memory.represent,
    _ represent _ new {a : constant : 1}
]
-----
{a : constant : 1}
=====
represent non-recursive
-----
_ do [
    new = _ import _memory.new,
    represent = _ import _memory.represent,
    remove = _ import _map.remove,
    second = _ import _pair.second,
    m = _ represent _ new {b : . : _ new {}},
    b = m which _ remove _b,
    b = b which _ second .,
    b which _ type .
]
-----
memory
=====
reverse
-----
_ do [
    new = _ import _memory.new,
    reverse = _ import _memory.reverse,
    c1 = _ new {
        a : none : 1,
        b : still : 2,
        c : final : 3,
        d : static : 4,
        e : constant : 5,
    },
    c2 = _ new {
        a : none : 1,
        b : final : 2,
        c : still : 3,
        d : static : 4,
        e : constant : 5,
    },
    (c1 == _ reverse c2) and (c2 == _ reverse c1)
]
-----
true
