length
-----
_ do [
    .length set _ import _memory.length,
    .new set _ import _memory.new,
    .any set _ import _value.any,
    .m set _ new {
        a : . : _ any .,
        b : . : _ any .,
        c : . : _ any .,
        d : . : _ any .,
    },
    m which _ length _
]
-----
4
=====
length == repr length
-----
_ do [
    .memory.length set _ import _memory.length,
    .map.length set _ import _map.length,
    .represent set _ import _memory.represent,
    .any set _ import _value.any,
    .m set _ any _memory,
    .m1 set _ represent m,
    .l set m which _ memory.length _,
    .l1 set m1 which _ map.length _,
    l == l1
]
-----
true
=====
get none
-----
_ do [
    .any set _ import _value.any,
    .a set _ any .,
    a == .a get _
]
-----
true
=====
get final
-----
_ do [
    .any set _ import _value.any,
    .new set _ import _memory.new,
    .v set _ any .,
    _a set _ new {_b : _final : v},
    v == _a which _ get _b
]
-----
true
=====
get still
-----
_ do [
    .any set _ import _value.any,
    .new set _ import _memory.new,
    .v set _ any .,
    _a set _ new {_b : _still : v},
    v == _a which _ get _b
]
-----
true
=====
get static
-----
_ do [
    .any set _ import _value.any,
    .new set _ import _memory.new,
    .v set _ any .,
    _a set _ new {_b : _static : v},
    v == _a which _ get _b
]
-----
true
=====
get const
-----
_ do [
    .any set _ import _value.any,
    .new set _ import _memory.new,
    .v set _ any .,
    _a set _ new {_b : _constant : v},
    v == _a which _ get _b
]
-----
true
=====
move ref
-----
_ do [
    .any set _ import _value.any,
    .exist set _ import _memory.exist,
    _a set _ any .,
    .b set _ get _a,
    (b == _a move _) and (_ not _a exist _)
]
-----
true
=====
move indirect
-----
_ do [
    .any set _ import _value.any,
    .exist set _ import _memory.exist,
    _a set _ any .,
    .b set _a,
    .c set _ get _a,
    (c == b move _) and (_ not _a exist _)
]
-----
true
=====
move final
-----
_ do [
    .any set _ import _value.any,
    .new set _ import _memory.new,
    .exist set _ import _memory.exist,
    .v set _ any .,
    _a set _ new {_b : _final : v},
    (. == _a which _ move _b) and (_a which _ exist _b)
]
-----
true
=====
move still
-----
_ do [
    .any set _ import _value.any,
    .new set _ import _memory.new,
    .exist set _ import _memory.exist,
    .v set _ any .,
    _a set _ new {_b : _still : v},
    (v == _a which _ move _b) and (_ not _a which _ exist _b)
]
-----
true
=====
move static
-----
_ do [
    .any set _ import _value.any,
    .new set _ import _memory.new,
    .exist set _ import _memory.exist,
    .v set _ any .,
    _a set _ new {_b : _static : v},
    (. == _a which _ move _b) and (_a which _ exist _b)
]
-----
true
=====
move const
-----
_ do [
    .any set _ import _value.any,
    .new set _ import _memory.new,
    .exist set _ import _memory.exist,
    .v set _ any .,
    _a set _ new {_b : _constant : v},
    (. == _a which _ move _b) and (_a which _ exist _b)
]
-----
true
=====
= none
-----
_ do [
    .contract set _ import _memory.contract,
    .a set 1,
    [a, .a contract _]
]
-----
[1, _none]
=====
= const
-----
_ do [
    .set_contract set _ import _memory.set_contract,
    .p set 1 : 2,
    .p set_contract _final,
    p which ..first set 3,
    p which _ get .first
]
-----
1
=====
none set return
-----
_ do [
    .any set _ import _value.any,
    _a set 1,
    1 == _a set _ any .
]
-----
true
=====
none mutate
-----
_ do [
    .set_first set _ import _pair.set_first,
    .a set 1 : 2,
    a which _ set_first 3,
    a
]
-----
3 : 2
=====
final mutate
-----
_ do [
    .any set _ import _value.any,
    .set_contract set _ import _memory.set_contract,
    .set_first set _ import _pair.set_first,
    .a set 1 : 2,
    .a set_contract _final,
    a which _ set_first _ any .,
    a
]
-----
1 : 2
=====
final set
-----
_ do [
    .any set _ import _value.any,
    .set_contract set _ import _memory.set_contract,
    .final_a set 1,
    .final_a set_contract _final,
    .final_a set _ any .,
    final_a
]
-----
1
=====
set_contract still none
-----
_ do [
    .any set _ import _value.any,
    .new set _ import _memory.new,
    .set_contract set _ import _memory.set_contract,
    .contract set _ import _memory.contract,
    .c set _ new {_a : _still : _ any .},
    c which _a set_contract _none,
    c which _ contract _a
]
-----
_none
=====
set_contract still none
-----
_ do [
    .any set _ import _value.any,
    .new set _ import _memory.new,
    .set_contract set _ import _memory.set_contract,
    .contract set _ import _memory.contract,
    .c set _ new {_a : _still : _ any .},
    c which _a set_contract _final,
    c which _ contract _a
]
-----
_final
=====
set_contract none final
-----
_ do [
    .any set _ import _value.any,
    .set_contract set _ import _memory.set_contract,
    .contract set _ import _memory.contract,
    .a set _ any .,
    .a set_contract _final,
    .a contract _
]
-----
_final
=====
set_contract none still
-----
_ do [
    .any set _ import _value.any,
    .set_contract set _ import _memory.set_contract,
    .contract set _ import _memory.contract,
    .a set _ any .,
    .a set_contract _still,
    .a contract _
]
-----
_none
=====
set_contract final still
-----
_ do [
    .any set _ import _value.any,
    .new set _ import _memory.new,
    .set_contract set _ import _memory.set_contract,
    .contract set _ import _memory.contract,
    .c set _ new {_a : _final : _ any .},
    c which _a set_contract _still,
    c which _ contract _a
]
-----
_final
=====
set_contract final none
-----
_ do [
    .any set _ import _value.any,
    .new set _ import _memory.new,
    .set_contract set _ import _memory.set_contract,
    .contract set _ import _memory.contract,
    .c set _ new {_a : _final : _ any .},
    c which _a set_contract _none,
    c which _ contract _a
]
-----
_final
=====
set_contract static const
-----
_ do [
    .any set _ import _value.any,
    .new set _ import _memory.new,
    .set_contract set _ import _memory.set_contract,
    .contract set _ import _memory.contract,
    .c set _ new {_a : _static : _ any .},
    c which _a set_contract _constant,
    c which _ contract _a
]
-----
_static
=====
set_contract static still
-----
_ do [
    .any set _ import _value.any,
    .new set _ import _memory.new,
    .set_contract set _ import _memory.set_contract,
    .contract set _ import _memory.contract,
    .c set _ new {_a : _static : _ any .},
    c which _a set_contract _still,
    c which _ contract _a
]
-----
_static
=====
set_contract static final
-----
_ do [
    .any set _ import _value.any,
    .new set _ import _memory.new,
    .set_contract set _ import _memory.set_contract,
    .contract set _ import _memory.contract,
    .c set _ new {_a : _static : _ any .},
    c which _a set_contract _final,
    c which _ contract _a
]
-----
_static
=====
set_contract static none
-----
_ do [
    .any set _ import _value.any,
    .new set _ import _memory.new,
    .set_contract set _ import _memory.set_contract,
    .contract set _ import _memory.contract,
    .c set _ new {_a : _static : _ any .},
    c which _a set_contract _none,
    c which _ contract _a
]
-----
_static
=====
exist false
-----
_ do [
    .exist set _ import _memory.exist,
    _a exist _
]
-----
false
=====
exist true
-----
_ do [
    .any set _ import _value.any,
    .exist set _ import _memory.exist,
    _a set _ any .,
    _a exist _
]
-----
true
=====
static move
-----
_ do [
    .new set _ import _memory.new,
    .c set _ new {_a : _static : 1},
    c which _ move _a,
    c which _ get _a
]
-----
1
=====
static set to static
-----
_ do [
    .new set _ import _memory.new,
    .c set _ new {_static_a : _static : 1},
    c which _static_a set 2,
    c which _ get _static_a
]
-----
1
=====
which free free
-----
_ do [
    .u set .,
    u which 1 + 1
]
-----
2
=====
which free mutate
-----
_ do [
    .u set .,
    .a set 1,
    u which _ move .a,
    a
]
-----
1
=====
represent default
-----
_ do [
    .new set _ import _memory.new,
    .represent set _ import _memory.represent,
    _ represent _ new {}
]
-----
{}
=====
represent else
-----
_ do [
    .new set _ import _memory.new,
    .represent set _ import _memory.represent,
    _ represent _ new {a : _constant : 1}
]
-----
{a : _constant : 1}
=====
represent non-recursive
-----
_ do [
    .new set _ import _memory.new,
    .represent set _ import _memory.represent,
    .remove set _ import _map.remove,
    .second set _ import _pair.second,
    .m set _ represent _ new {_b : . : _ new {}},
    .b set m which _ remove _b,
    .b set b which _ second .,
    b which _ type .
]
-----
_memory
=====
reverse
-----
_ do [
    .new set _ import _memory.new,
    .reverse set _ import _memory.reverse,
    .c1 set _ new {
        a : _none : 1,
        b : _still : 2,
        c : _final : 3,
        d : _static : 4,
        e : _constant : 5,
    },
    .c2 set _ new {
        a : _none : 1,
        b : _final : 2,
        c : _still : 3,
        d : _static : 4,
        e : _constant : 5,
    },
    (c1 == _ reverse c2) and (c2 == _ reverse c1)
]
-----
true
