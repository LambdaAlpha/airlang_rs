recursive call
-----
_ do [
    .f set _ function {
        code : (. : .i) : .i,
        prelude : {},
    },
    _ f _ not true
]
-----
false
=====
call external func
-----
_ do [
    .f set _ function {
        code : (. : .i) : _ form _ not .i,
        prelude : {},
    },
    _ f _ not true
]
-----
true
=====
call internal func
-----
_ do [
    .f set _ function {
        code : (. : .i) : _ form _ .not .i,
        prelude : {
            not : not
        },
    },
    _ f _ not true
]
-----
true
=====
call rename
-----
_ do [
    .f set _ function {
        code : (. : .a) : _ form _ .n .a,
        prelude : {
            n : not
        },
    },
    _ f _ not true
]
-----
true
=====
stateful
-----
_ do [
    .new_link set _ import _link.new,
    .link_which set _ import _link.which,
    .f set _ function {
        code : (. : .) : _ form _ do [
            ..i set .a link_which get : _i,
            .a link_which set : _i : .i + 1,
            .i
        ],
        prelude : {
            a : _ new_link {_i : 0}
        },
    },
    [_ f ., _ f ., _ f .]
]
-----
[0, 1, 2]
=====
multiple stateful
-----
_ do [
    .new_link set _ import _link.new,
    .link_which set _ import _link.which,
    .f set _ data _ function {
        code : (. : .) : _ form _ do [
            ..i set .a link_which get : _value,
            .a link_which set : _value : .i + 1,
            .i
        ],
        prelude : {
            a : _ new_link .(0)
        },
    },
    .f1 set _ eval f,
    .f2 set _ eval f,
    [_ f1 ., _ f1 ., _ f1 ., _ f2 ., _ f2 ., _ f2 .]
]
-----
[0, 1, 2, 0, 1, 2]
=====
const const
-----
_ do [
    .link_which set _ import _link.which,
    _a set 1,
    .f set _ function {
        code : (.c : .) : _ form .c link_which get : _a,
        context_constant : true,
        prelude : {},
    },
    _ f .
]
-----
1
=====
mutable const
-----
_ do [
    .link_which set _ import _link.which,
    _a set 1,
    .f set _ function {
        code : (.c : .) : _ form .c link_which get : _a,
        context_constant : false,
        prelude : {},
    },
    _ f .
]
-----
1
=====
mutable mutate
-----
_ do [
    .link_which set _ import _link.which,
    .f set _ function {
        code : (.c : .i) : _ form .c link_which set : .i : 2,
        context_constant : false,
        prelude : {},
    },
    .a set 1,
    _ f .a,
    a
]
-----
2
=====
const mutate fail
-----
_ do [
    .link_which set _ import _link.which,
    .config.new set _ import _config.new,
    .link.new set _ import _link.new,
    .where set _ import _config.where,
    .is_aborted set _ import _error.is_aborted,
    .f set _ function {
        code : (.c : .i) : _ form .c link_which set : .i : 2,
        context_constant : true,
        prelude : {},
    },
    .c set _ config.new {
        _prelude : _ link.new {
            f : f,
            a : 1,
        },
    },
    c where _ f .a,
    .c which is_aborted : .,
]
-----
true
=====
const free
-----
_ do [
    .a set .,
    .f set _ function {
        code : (_c : .) : 1,
        context_constant : true,
        prelude : {},
    },
    .a which f : .
]
-----
1
=====
ctx name occupied
-----
_ do [
    .a set 1,
    .f set _ function {
        code : (.ctx : .) : 2,
        context_constant : true,
        prelude : {
            ctx : 3
        },
    },
    _ f .,
    a == 1
]
-----
true
=====
ctx explicit
-----
_ do [
    .link_which set _ import _link.which,
    .set_left set _ import _pair.set_left,
    .a set 1 : 2,
    .f set _ function {
        code : (.p : .i) : _ form .p link_which set_left : .i,
        prelude : {},
    },
    .a which f : 3,
    a
]
-----
3 : 2
=====
repr
-----
_ do [
    .represent set _ import _function.represent,
    _ represent _ function {
        code : (.c : .i) : .i,
        prelude : {},
    }
]

-----
{
    context_constant : false,
    input_raw : false,
    code : (c : i) : i,
    prelude : {}
}
=====
repr primitive free
-----
_ do [
    .represent set _ import _function.represent,
    .function.get_code set _ import _function.get_code,
    .not_code set .not which function.get_code : .,
    .repr set {
        context_constant : true,
        input_raw : false,
        code : not_code,
    },
    repr == _ represent not
]
-----
true
=====
repr const
-----
_ do [
    .represent set _ import _function.represent,
    _ represent _ function {
        code : (_c : .i) : .i,
        context_constant : true
    }
]
-----
{
    context_constant : true,
    input_raw : false,
    code : (_c : i) : i,
    prelude : .,
}
=====
repr primitive const
-----
_ do [
    .represent set _ import _function.represent,
    .function.get_code set _ import _function.get_code,
    .type_code set .get_type which function.get_code : .,
    .repr set {
        context_constant : true,
        input_raw : true,
        code : type_code,
    },
    repr == _ represent get_type
]
-----
true
=====
repr composite
-----
_ do [
    .represent set _ import _function.represent,
    .repr set {
        context_constant : true,
        input_raw : false,
        code : (_ctx : .in) : .in,
        prelude : {},
    },
    .new_repr set _ represent _ function repr,
    repr == new_repr
]
-----
true
=====
is_context_free free
-----
_ do [
    .is_context_free set _ import _function.is_context_free,
    .function which is_context_free : .
]
-----
true
=====
is_context_free constant
-----
_ do [
    .is_context_free set _ import _function.is_context_free,
    .get which is_context_free : .
]
-----
false
=====
is_context_free mutable
-----
_ do [
    .is_context_free set _ import _function.is_context_free,
    .code which is_context_free : .
]
-----
false
=====
is_context_constant free
-----
_ do [
    .is_context_constant set _ import _function.is_context_constant,
    .function which is_context_constant : .
]
-----
true
=====
is_context_constant constant
-----
_ do [
    .is_context_constant set _ import _function.is_context_constant,
    .get which is_context_constant : .
]
-----
true
=====
is_context_constant mutable
-----
_ do [
    .is_context_constant set _ import _function.is_context_constant,
    .code which is_context_constant : .
]
-----
false
=====
is_input_free free
-----
_ do [
    .is_input_free set _ import _function.is_input_free,
    .abort which is_input_free : .
]
-----
true
=====
is_input_free raw
-----
_ do [
    .is_input_free set _ import _function.is_input_free,
    .data which is_input_free : .
]
-----
false
=====
is_input_free eval
-----
_ do [
    .is_input_free set _ import _function.is_input_free,
    .id which is_input_free : .
]
-----
false
=====
is_input_raw free
-----
_ do [
    .is_input_raw set _ import _function.is_input_raw,
    .abort which is_input_raw : .
]
-----
true
=====
is_input_raw raw
-----
_ do [
    .is_input_raw set _ import _function.is_input_raw,
    .data which is_input_raw : .
]
-----
true
=====
is_input_raw eval
-----
_ do [
    .is_input_raw set _ import _function.is_input_raw,
    .id which is_input_raw : .
]
-----
false
=====
is_primitive primitive
-----
_ do [
    .is_primitive set _ import _function.is_primitive,
    .not which is_primitive : .
]
-----
true
=====
is_primitive composite
-----
_ do [
    .is_primitive set _ import _function.is_primitive,
    .f set _ function {code : (. : .) : .},
    .f which is_primitive : .
]
-----
false
=====
get_code
-----
_ do [
    .function.get_code set _ import _function.get_code,
    .f set _ function {
        code : (_ctx : .i) : .i
    },
    .f which function.get_code : .
]
-----
(_ctx : i) : i
=====
prelude
-----
_ do [
    .function.get_prelude set _ import _function.get_prelude,
    .any set _ import _value.any,
    .prelude set _ any .,
    .f set _ function {
        code : (. : .) : .,
        prelude : prelude
    },
    (.f which function.get_prelude : .) == prelude
]
-----
true
=====
apply free
-----
_ do [
    not apply _ not true
]
-----
true
=====
apply const
-----
_ do [
    _a set 1,
    get apply _a
]
-----
1
=====
apply mut
-----
_ do [
    set apply .a : 1,
    a
]
-----
1
=====
apply eval
-----
_ do [
    test apply true : [.a set true] : [.b set true],
    a and b
]
-----
true
=====
recurse
-----
_ do [
    .g set _ function {
        code : (. : .fi) : _ form _ do [
            (..f : ..i) = .fi,
            (.i < 1) test [
                0
            ] : [
                .i + .f .f .i - 1
            ]
        ],
        prelude : {},
    },
    g g 10
]
-----
55
