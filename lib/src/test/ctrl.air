do empty list
-----
_ do [
]
-----
.
=====
do single
-----
_ do [
    1
]
-----
1
=====
do multiple
-----
_ do [
    1,
    2
]
-----
2
=====
do recursive 1
-----
_ do [
    _ do [
        1,
        2
    ],
    3
]
-----
3
=====
do recursive 2
-----
_ do [
    1,
    _ do [
        2,
        3
    ]
]
-----
3
=====
do return true
-----
_ do [
    1,
    2,
    true _return 3,
    4
]
-----
3
=====
do return false
-----
_ do [
    1,
    2,
    false _return 3,
    4
]
-----
4
=====
do return scope 1
-----
_ do [
    1,
    _ do [
        2,
        true _return 3,
        4
    ],
    5
]
-----
5
=====
do return scope 2
-----
_ do [
    1,
    .a set _ do [
        2,
        true _return 3,
        4
    ],
    a + 2
]
-----
5
=====
do return eval
-----
_ do [
    .b set 2,
    (b > 0) _return b - 1,
    b + 1
]
-----
1
=====
do list
-----
_ do [
    []
]
-----
[]
=====
test true
-----
true test [1] : [2]
-----
1
=====
test false
-----
false test [1] : [2]
-----
2
=====
test else .
-----
true test [1] : []
-----
1
=====
test conditional eval
-----
_ do [
    .a set 1,
    true test [
        1
    ] : [
        .a set 2
    ],
    a
]
-----
1
=====
test recursive
-----
true test [
    false test [1] : [2]
] : [
    3
]
-----
2
=====
test return
-----
true test [
    1,
    true _return 2,
    3
] : [
    4
]
-----
2
=====
test return
-----
true test [
    1,
    true _return 2,
    3
] : [
    4
]
-----
2
=====
test list
-----
true test [
    []
] : [
]
-----
[]
=====
switch key
-----
.a switch {
    a : [_ not true],
    b : [1]
}
-----
false
=====
switch default
-----
.a switch {
} : [.b]
-----
b
=====
switch not eval
-----
_ do [
    .a set 0,
    .b switch {
        c : [.a set 1],
        d : [.a set 2]
    },
    a
]
-----
0
=====
switch block
-----
.a switch {
    a : [.b set 2, b]
}
-----
2
=====
match pattern
-----
[1, 2, 3] match [
    [.a, .b, .c] : [a + b + c]
]
-----
6
=====
match order
-----
_ do [
    .exist set _ import _memory.exist,
    [1, 2, 3] match [
        [2, .a, .b] : [.x set 1],
        [1, .c, .d] : [.y set 1],
        [.e, 2, .f] : [.z set 1],
    ],
    [
        .a exist _,
        .b exist _,
        c,
        d,
        .e exist _,
        .f exist _,
        .x exist _,
        y,
        .z exist _
    ]
]
-----
[false, false, 2, 3, false, false, false, 1, false]
=====
match eval
-----
_ do [
    .a set 1,
    a match [
        1 : [1 + 2],
        2 : [2 + 3]
    ]
]
-----
3
=====
match exist
-----
1 match [
    1 : [2], 2 : [3]
]
-----
2
=====
match default
-----
3 match [
    1 : [2],
    2 : [3],
    __ : [4]
]
-----
4
=====
match conditional eval exist
-----
_ do [
    .exist set _ import _memory.exist,
    1 match [
        1 : [.a set 1],
        2 : [.b set 2],
        __ : [.c set 3]
    ],
    [a, .b exist _, .c exist _]
]
-----
[1, false, false]
=====
match conditional eval default
-----
_ do [
    .exist set _ import _memory.exist,
    3 match [
        1 : [.a set 1],
        2 : [.b set 2],
        __ : [.c set 3]
    ],
    [.a exist _, .b exist _, c]
]
-----
[false, false, 3]
=====
match key
-----
_ do [
    .a set .a,
    a match [
        .*a : [1],
        .*b : [2]
    ]
]
-----
1
=====
match return
-----
1 match [
    1 : [
        2,
        true _return 3,
        4
    ]
]
-----
3
=====
match return
-----
1 match [
    1 : [
        2,
        true _return 3,
        4
    ]
]
-----
3
=====
match do
-----
1 match [
    1 : [1, 2]
]
-----
2
=====
match list
-----
1 match [
    1 : [[]]
]
-----
[]
=====
match bit
-----
true match [
    true : [1],
    false : [2]
]
-----
1
=====
loop false
-----
_ do [
    .a set 1,
    false loop [
        .a set 2
    ],
    a
]
-----
1
=====
loop multiple
-----
_ do [
    .a set 0,
    .b set 0,
    (a < 100) loop [
        .a set a + 17,
        .b set b + 1
    ],
    b
]
-----
6
=====
loop test
-----
_ do [
    .a set 42,
    .b set 24,
    (a <> b) loop [
        (a > b) test [
            .a set a - b
        ] : [
            .b set b - a
        ]
    ],
    a
]
-----
6
=====
loop continue
-----
_ do [
    .a set 0,
    .b set 0,
    (b < 5) loop [
        .b set b + 1,
        (b == 2) _continue .,
        .a set a + b,
    ],
    a
]
-----
13
=====
loop return
-----
_ do [
    .a set 0,
    .b set 0,
    (b < 5) loop [
        (a > 5) _return a,
        .b set b + 1,
        .a set a + b,
    ]
]
-----
6
=====
iterate list
-----
_ do [
    .sum set 0,
    [1, 2, 3, 4, 5] iterate i : [
        .sum set sum + i
    ],
    sum
]
-----
15
=====
iterate empty list
-----
_ do [
    .sum set 0,
    [] iterate i : [
        .sum set sum + i
    ],
    sum
]
-----
0
=====
iterate return 1
-----
[1, 2, 3, 4, 5] iterate i : [
    (i == 3) _return true
]
-----
true
=====
iterate return 2
-----
_ do [
    [1, 2, 3, 4, 5] iterate i : [
        (i == 3) _return .,
        .a set i
    ],
    a
]
-----
2
=====
iterate continue
-----
_ do [
    .a set 0,
    .b set 0,
    [1, 2, 3, 4, 5] iterate i : [
        .a set a + i,
        (i == 3) _continue .,
        .b set b + i
    ],
    a : b
]
-----
15 : 12
=====
iterate list map
-----
_ do [
    .push set _ import _list.push,
    .a set [],
    [1, 2, 3, 4, 5] iterate i : [
        a which _ push i + 1
    ],
    a
]
-----
[2, 3, 4, 5, 6]
=====
iterate integer
-----
_ do [
    .sum set 0,
    10 iterate i : [
        .sum set sum + i
    ],
    sum
]
-----
45
=====
iterate integer 0
-----
_ do [
    .sum set 0,
    0 iterate i : [
        .sum set sum + i
    ],
    sum
]
-----
0
=====
iterate integer negative
-----
0-1 iterate i : []
-----
.
=====
iterate byte
-----
_ do [
    .push set _ import _list.push,
    .b set [],
    byte(1122334455) iterate i : [
        b which _ push i
    ],
    b
]
-----
[byte(11), byte(22), byte(33), byte(44), byte(55)]
=====
iterate key
-----
_ do [
    .push set _ import _list.push,
    .s set [],
    .abc iterate i : [
        s which _ push i
    ],
    s
]
-----
[a, b, c]
=====
iterate text
-----
_ do [
    .push set _ import _list.push,
    .t set [],
    "hello" iterate i : [
        t which _ push i
    ],
    t
]
-----
["h", "e", "l", "l", "o"]
=====
iterate map
-----
_ do [
    .push set _ import _list.push,
    .new_map set _ import _map.new,
    .kv set [],
    {1 : 2, 3 : 4} iterate i : [
        kv which _ push i
    ],
    _ new_map kv
]
-----
{1 : 2, 3 : 4}
