read ref
-----
_ do [
    any = _ import .value.any,
    read = _ import .context.read,
    a = _ any .,
    a == .a read _
]
-----
true
=====
read indirect
-----
_ do [
    any = _ import .value.any,
    read = _ import .context.read,
    a = _ any .,
    b = .a,
    a == b read _
]
-----
true
=====
= read
-----
_ do [
    a = 1,
    a
]
-----
1
=====
= return
-----
_ do [
    any = _ import .value.any,
    a = 1,
    a = _ any .
]
-----
1
=====
= another
-----
_ do [
    any = _ import .value.any,
    a = _ any .,
    a = 2,
    a
]
-----
2
=====
= self
-----
_ do [
    a = 1,
    a = a,
    a
]
-----
1
=====
= indirect
-----
_ do [
    a = .b,
    @a = 1,
    b
]
-----
1
=====
= special key 1
-----
_ do [
    ..a = 1,
    @.a
]
-----
1
=====
= special key 2
-----
_ do [
    first = _ import .pair.first,
    ..p = 1 : 2,
    .p which _ first .
]
-----
1
=====
= special key 3
-----
_ do [
    #*a = 1,
    *a
]
-----
1
=====
= special key 4
-----
_ do [
    ##a = 1,
    #a
]
-----
1
=====
= destruct pair
-----
_ do [
    (a : b) = 1 : 2,
    a : b
]
-----
1 : 2
=====
= destruct pair return
-----
_ do [
    a = 1,
    b = 2,
    (a : b) = 3 : 4
]
-----
1 : 2
=====
= destruct recursive
-----
_ do [
    (a : b : c) = 1 : 2 : 3,
    [a, b, c]
]
-----
[1, 2, 3]
=====
= destruct call
-----
_ do [
    (_ f a) = _ form _ 1 2,
    [f, a]
]
-----
[1, 2]
=====
= destruct infix
-----
_ do [
    (a b c) = _ form 1 2 3,
    [a, b, c]
]
-----
[1, 2, 3]
=====
= destruct list equal length
-----
_ do [
    [a, b, c] = [1, 2, 3],
    [a, b, c]
]
-----
[1, 2, 3]
=====
= destruct list more value
-----
_ do [
    [a, b] = [1, 2, 3],
    [a, b]
]
-----
[1, 2]
=====
= destruct list more pattern
-----
_ do [
    a = 1,
    b = 2,
    [a, b] = [3],
    [a, b]
]
-----
[3, .]
=====
= destruct list more pattern return
-----
_ do [
    a = 1,
    b = 2,
    [a, b] = [3]
]
-----
[1, 2]
=====
= destruct map symbol key
-----
_ do [
    {a : a, b : b} = {a : 1, b : 2, c : 3},
    [a, b]
]
-----
[1, 2]
=====
= destruct map other key
-----
_ do [
    {1 : a, 3 : b} = {1 : 2, 3 : 4},
    [a, b]
]
-----
[2, 4]
=====
= destruct map not full match
-----
_ do [
    a = 1,
    b = 2,
    {3 : a, 4 : b} = {3 : 5, 6 : 7}
]
-----
{3 : 1, 4 : 2}
=====
= destruct match
-----
_ do [
    [a, 2, c] = [1, 2, 3],
    [a, c]
]
-----
[1, 3]
=====
= destruct not match
-----
_ do [
    a = 1,
    c = 3,
    [a, 2, c] = [2, 3, 4],
    [a, c]
]
-----
[1, 3]
=====
= pair ctx
-----
_ do [
    first = _ import .pair.first,
    p = 1 : 2,
    p which first = 3,
    p which _ first .
]
-----
3
=====
= call ctx
-----
_ do [
    function = _ import .call.function,
    t = _ form _ func input,
    t which function = .c,
    t which _ function .
]
-----
c
=====
= list ctx
-----
_ do [
    get = _ import .list.get,
    l = [1, 2, 3],
    l which .1 = 4,
    l which _ get 1
]
-----
4
=====
= map ctx
-----
_ do [
    get = _ import .map.get,
    m = {a : 1, b : 2},
    m which a = 3,
    m which _ get .a
]
-----
3
=====
= map ctx not exist
-----
_ do [
    get = _ import .map.get,
    m = {},
    m which a = 3,
    m which _ get .a
]
-----
3
=====
is_constant default
-----
_ do [
    is_constant = _ import .context.is_constant,
    _ is_constant .
]
-----
false
=====
is_constant true
-----
_ do [
    new = _ import .memory.new,
    set_contract = _ import .memory.set_contract,
    is_constant = _ import .context.is_constant,
    a = _ new {},
    .a set_contract .final,
    a which _ is_constant .
]
-----
true
=====
is_constant false
-----
_ do [
    new = _ import .memory.new,
    is_constant = _ import .context.is_constant,
    a = _ new {},
    a which _ is_constant .
]
-----
false
=====
which 1
-----
_ do [
    new = _ import .memory.new,
    set_first = _ import .pair.set_first,
    a = _ new {p : . : 1 : 2},
    b = 3,
    a which _ apply .p which _ set_first b,
    a which _ move .p,
]
-----
3 : 2
=====
which 2
-----
_ do [
    new = _ import .memory.new,
    set_first = _ import .pair.set_first,
    a = _ new {
        p : . : 1 : 2,
        b : . : 3,
    },
    a which _ apply .p which _ set_first .b,
    a which _ move .p,
]
-----
3 : 2
=====
which 3
-----
_ do [
    new = _ import .memory.new,
    set_first = _ import .pair.set_first,
    a = _ new {
        set_first : . : set_first,
        p : . : 1 : 2,
        b : . : 3,
    },
    a which _ apply .p which _ .set_first .b,
    a which _ move .p,
]
-----
3 : 2
=====
which recursive
-----
_ do [
    new = _ import .memory.new,
    a = _ new {b : . : _ new {c : . : 1}},
    a which _ apply .b which _ apply ..c
]
-----
1
=====
which self
-----
_ do [
    self = _ import .context.self,
    u = 1,
    u which _ self .
]
-----
1
=====
self
-----
_ do [
    self = _ import .context.self,
    a = 1,
    b = _ self .,
    b which _ apply .a
]
-----
1
=====
self non-sync
-----
_ do [
    any = _ import .value.any,
    self = _ import .context.self,
    exist = _ import .memory.exist,
    a = _ self .,
    b = _ any .,
    a which _ exist .b
]
-----
false
