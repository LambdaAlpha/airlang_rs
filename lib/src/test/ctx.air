get ref
-----
_ do [
    .any set _ import _value.any,
    _a set _ any .,
    :_a == _a get _
]
-----
true
=====
get indirect
-----
_ do [
    .any set _ import _value.any,
    .a set _ any .,
    .b set .a,
    a == b get _
]
-----
true
=====
set get
-----
_ do [
    _a set 1,
    _a get _
]
-----
1
=====
set another
-----
_ do [
    .any set _ import _value.any,
    .a set _ any .,
    .a set 2,
    a
]
-----
2
=====
set self
-----
_ do [
    .a set 1,
    .a set a,
    a
]
-----
1
=====
set indirect
-----
_ do [
    .a set .b,
    :a set 1,
    b
]
-----
1
=====
set special key 1
-----
_ do [
    _a set 1,
    :_a
]
-----
1
=====
set special key 2
-----
_ do [
    .get_left set _ import _pair.get_left,
    .:p set 1 : 2,
    .:p which get_left : .
]
-----
1
=====
= destruct cell
-----
_ do [
    .(.v) = .(true),
    v
]
-----
true
=====
= destruct pair
-----
_ do [
    (.a : .b) = 1 : 2,
    a : b
]
-----
1 : 2
=====
= destruct recursive
-----
_ do [
    (.a : .b : .c) = 1 : 2 : 3,
    [a, b, c]
]
-----
[1, 2, 3]
=====
= destruct call
-----
_ do [
    (_ form _ .f .a) = _ data _ 1 2,
    [f, a]
]
-----
[1, 2]
=====
= destruct infix
-----
_ do [
    (_ form .a .b .c) = _ data 1 2 3,
    [a, b, c]
]
-----
[1, 2, 3]
=====
= destruct list equal length
-----
_ do [
    [.a, .b, .c] = [1, 2, 3],
    [a, b, c]
]
-----
[1, 2, 3]
=====
= destruct list more value
-----
_ do [
    [.a, .b] = [1, 2, 3],
    [a, b]
]
-----
[1, 2]
=====
= destruct list more pattern
-----
_ do [
    .config.new set _ import _config.new,
    .link.new set _ import _link.new,
    .where set _ import _config.where,
    .is_aborted set _ import _error.is_aborted,
    .c set _ config.new {
        _prelude : _ link.new {
            = : =,
        },
    },
    c where [.a, .b] = [3],
    .c which is_aborted : .,
]
-----
true
=====
= destruct map key
-----
_ do [
    {a : .a, b : .b} = {a : 1, b : 2, c : 3},
    [a, b]
]
-----
[1, 2]
=====
= destruct map other key
-----
_ do [
    {1 : .a, 3 : .b} = {1 : 2, 3 : 4},
    [a, b]
]
-----
[2, 4]
=====
= destruct match
-----
_ do [
    [.a, 2, .c] = [1, 2, 3],
    [a, c]
]
-----
[1, 3]
=====
= pair ctx
-----
_ do [
    .p set 1 : 2,
    .p which set : _left : 3,
    .p which get : _left
]
-----
3
=====
= call ctx
-----
_ do [
    .c set _ data _ func input,
    .c which set : _function : _f,
    .c which get : _function
]
-----
_f
=====
= list ctx
-----
_ do [
    .list.get set _ import _list.get,
    .l set [1, 2, 3],
    .l which set : _first : 4,
    .l which list.get : 0
]
-----
4
=====
= map ctx
-----
_ do [
    .map.get set _ import _map.get,
    .m set {a : 1, b : 2},
    .m which set : _a : 3,
    .m which map.get : _a
]
-----
.(3)
=====
= map ctx not exist
-----
_ do [
    .map.get set _ import _map.get,
    .m set {},
    .m which set : _a : 3,
    .m which map.get : _a
]
-----
.(3)
=====
is_constant default
-----
_ do [
    .is_constant set _ import _context.is_constant,
    _ is_constant .
]
-----
false
=====
is_constant true
-----
_ do [
    .is_constant set _ import _context.is_constant,
    .const_link set _ import _link.new_constant,
    .link_which set _ import _link.which,
    .a set _ const_link .,
    a link_which is_constant : .
]
-----
true
=====
is_constant false
-----
_ do [
    .is_constant set _ import _context.is_constant,
    _a set {},
    _a which is_constant : .
]
-----
false
=====
which 1
-----
_ do [
    .set_left set _ import _pair.set_left,
    _a set {_p : 1 : 2},
    _a which eval : _ form _p which set_left : 3,
    _a which move : _p,
]
-----
3 : 2
=====
which 2
-----
_ do [
    .set_left set _ import _pair.set_left,
    _a set {
        _p : 1 : 2,
        _b : 3,
    },
    _a which eval : _ form _p which set_left : _ get _b,
    _a which move : _p,
]
-----
3 : 2
=====
which 3
-----
_ do [
    .set_left set _ import _pair.set_left,
    _a set {
        set_left : set_left,
        _p : 1 : 2,
        b : 3,
    },
    _a which eval : _ form _p which .set_left : .b,
    _a which move : _p,
]
-----
3 : 2
=====
which recursive
-----
_ do [
    _a set {_b : {_c : 1}},
    _a which eval : _ form _b which get : _c
]
-----
1
=====
which self
-----
_ do [
    .self set _ import _context.self,
    .u set 1,
    .u which self : .
]
-----
1
=====
self
-----
_ do [
    .self set _ import _context.self,
    _a set 1,
    .b set _ self .,
    .b which get : _a
]
-----
1
=====
self non-sync
-----
_ do [
    .any set _ import _value.any,
    .self set _ import _context.self,
    .contain set _ import _map.contain,
    .a set _ self .,
    _b set _ any .,
    .a which contain : _b
]
-----
false
