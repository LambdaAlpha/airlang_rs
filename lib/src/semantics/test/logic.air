;[
    p = (proposition {
        function : not,
        input : 1,
        output : 2,
    }),
    proposition_input p
]
# ---
1
# ===
;[
    p = (proposition {
        function : not,
        input : 1,
        output : 2,
    }),
    proposition_output p
]
# ---
2
# ===
;[
    p = (proposition {
        function : ==,
        input : 1,
        output : 1,
        context : (context {map : {a : 2}}),
    }),
    ctx = (proposition_before p),
    ctx eval_constant a
]
# ---
2
# ===
;[
    p = (proposition {
        function : ==,
        input : 1,
        output : 1,
        context : (context {map : {a : 2}}),
    }),
    ctx = (proposition_after p),
    ctx eval_constant a
]
# ---
2
# ===
;[
    p = (proposition {
        function : =,
        input : 1,
        output : 1,
        before : (context {map : {a : 2}}),
        after : (context {map : {a : 3}}),
    }),
    ctx = (proposition_before p),
    ctx eval_constant a
]
# ---
2
# ===
;[
    p = (proposition {
        function : =,
        input : 1,
        output : 1,
        before : (context {map : {a : 2}}),
        after : (context {map : {a : 3}}),
    }),
    ctx = (proposition_after p),
    ctx eval_constant a
]
# ---
3
# ===
;[
    p = (proposition {
        function : not,
        input : 1,
        output : 2,
    }),
    (proposition_function p) == not
]
# ---
't
# ===
;[
    map = {
        function : not,
        input : 't,
        output : 'f,
    },
    map == (proposition_represent (proposition map))
]
# ---
't
# ===
;[
    map = {
        function : ==,
        input : 't,
        output : 'f,
        context : (context {}),
    },
    map == (proposition_represent (proposition map))
]
# ---
't
# ===
;[
    map = {
        function : =,
        input : 't,
        output : 'f,
        before : (context {}),
        after : (context {}),
    },
    map == (proposition_represent (proposition map))
]
# ---
't
# ===
;[
    t = (theorem {
        function : not,
        input : 't,
    }),
    proposition_input t
]
# ---
't
# ===
;[
    t = (theorem {
        function : not,
        input : 't,
    }),
    proposition_output t
]
# ---
'f
# ===
;[
    t = (theorem {
        function : not,
        input : 't,
    }),
    (proposition_function t) == not
]
# ---
't
# ===
;[
    t = (theorem {
        function : not,
        input : 't,
    }),
    is_true t
]
# ---
't
# ===
;[
    t = (theorem {
        function : eval,
        input : (quote (('t not) 't)),
        before : (context {}),
    }),
    proposition_output t
]
# ---
'f
# ===
;[
    t = (theorem {
        function : ==,
        input : (value (a : b)),
        context : (context {
            map : {
                a : 1,
                b : 2,
            }
        })
    }),
    proposition_output t
]
# ---
'f
# ===
;[
    t = (theorem {
        function : =,
        input : (value (a : 1)),
        before : (context {})
    }),
    ctx = (proposition_before t),
    ctx eval_constant (('t is_null) a)
]
# ---
't
# ===
;[
    t = (theorem {
        function : =,
        input : (value (a : 1)),
        before : (context {})
    }),
    ctx = (proposition_after t),
    ctx eval_constant (('t is_null) a)
]
# ---
'f
# ===
;[
    map = (theorem_represent (theorem {
        function : not,
        input : 't,
    })),
    expected = {
        function : not,
        input : 't,
        output : 'f,
        truth : 't,
    },
    map == expected
]
# ---
't
# ===
;[
    map = (theorem_represent (theorem {
        function : ==,
        input : (1 : 2),
        context : (context {}),
    })),
    expected = {
        function : ==,
        input : (1 : 2),
        output : 'f,
        context : (context {}),
        truth : 't,
    },
    map == expected
]
# ---
't
# ===
;[
    map = (theorem_represent (theorem {
        function : =,
        input : ((value a) : 1),
        before : (context {}),
    })),
    expected = {
        function : =,
        input : ((value a) : 1),
        output : ',
        before : (context {}),
        after : (context {map : {a : 1}}),
        truth : 't,
    },
    map == expected
]
# ---
't
# ===
;[
    p = (proposition {
        function : not,
        input : 't,
        output : 'f,
    }),
    t = (prove p),
    is_true t
]
# ---
't
# ===
;[
    p = (proposition {
        function : not,
        input : 't,
        output : 't,
    }),
    t = (prove p),
    is_true t
]
# ---
'f
